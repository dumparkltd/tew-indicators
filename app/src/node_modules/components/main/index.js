//main
var React               = require('react')
var Fluxxor             = require('fluxxor')

//mixins
var FluxMixin           = Fluxxor.FluxMixin(React)
var StoreWatchMixin     = Fluxxor.StoreWatchMixin

//helpers
var uniq                = require('lodash.uniq')
var pluck               = require('lodash.pluck')
var contains            = require('lodash.contains')
var matches             = require('lodash.matches')
var omit                = require('lodash.omit')
var each                = require('lodash.foreach')
var result              = require('lodash.result')
var where               = require('lodash.where')
var qs                  = require('qs')

//components
var MultiSelect         = require('components/multi-select')
var FiltersGroup        = require('components/filters-group')
var IndicatorView       = require('components/indicator-view')

//debugging
var log             = require('debug')('src:components:main:index')

module.exports = React.createClass({

  mixins: [
    FluxMixin, StoreWatchMixin('route')
  ],

  contextTypes: {
    router: React.PropTypes.func
  },

  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      currentQuery: flux.store('route').getCurrentQuery()
    }
  },

  componentDidMount: function () {
    log('componentDidount')
    var location = this.context.router.getLocation()
    //add listener to update route store on query changes
    location.addChangeListener(function (loc) {
      if (loc.type === 'pop') {
        var queryString = loc.path.split('?')[1] || ''
        this.getFlux().actions.routes.pop(queryString)
        log('router:pop', loc, queryString)
      }
    }.bind(this))
  },

  render: function () {
    var flux             = this.getFlux()
    var currentQuery     = this.state.currentQuery
    var groupTypes       = ['ethnicity', "sex", "age", 'disability']
    var indicatorId      = 'unempl'
    var indicatorLabel   = 'Unemployment'
    var defaultKey       = 'all'

    var queryObject      = groupTypes.reduce(function (memo, groupType) {
      memo[groupType] = currentQuery[groupType] || defaultKey
      return memo
    }, {})
    log('queryObject', queryObject)

    //available data given the constraints of the query
    var data = flux.stores.data.query(queryObject)
    log('data', data)

    var optionObject     = groupTypes.reduce(function (memo, groupType) {
      //other options present in data
      var otherOptions = data.reduce(function(arr, d) {
        if(d[groupType] !== queryObject[groupType]) arr.push(d)
        return arr
      }, [])

      if (otherOptions.length === 0) {
        log('otherOptions.length === 0')
        var optionsForGroup = flux.stores[groupType].query()
        memo[groupType] = pluck(where(optionsForGroup, function (option) { return option.id !== defaultKey }), 'id')
      }
      else {
        memo[groupType] = uniq(pluck(otherOptions, groupType))
      }

      return memo
    }, {})
    log('optionObject', optionObject)

    //using lodash.where -> array
    var datum             = (data.length === 1) ? data[0] : { value: 'select groups' }
    log('datum', datum)

    return (
      <div>
        <FiltersGroup groupTypes={groupTypes} flux={flux} optionObject={optionObject} defaultKey={defaultKey} />
        <IndicatorView
          id={'indicator-view-'+indicatorId}
          header={indicatorLabel}
          datum={datum}  />
      </div>
    )
  },
})
