//main
var React       = require('react')


var makeGroupLabel = require('utils/makeGroupLabel')
var makeDataLabel = require('utils/makeDataLabel')
var getDataColour   = require('utils/getDataColour')
var getReference   = require('utils/getReference')

//helpers
var _ 					= require('lodash')

var d3          = require('d3')
var Row 								= require('react-bootstrap/lib/Row')
var Col           			= require('react-bootstrap/lib/Col')
var LineBarChart = require('./lineBarChart')

//logging
var log       	= require('debug')('components:indicator:timeline')



module.exports = React.createClass({

	propTypes : {
    flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // tehc urrent indicator
    datasets    : React.PropTypes.array, // datasets/timesteps
    breakdowns  : React.PropTypes.array, // breakdowns
    highlightGroups  : React.PropTypes.array, // breakdowns
    highlightDatasets : React.PropTypes.array, // breakdowns
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')    
    valueScale   : React.PropTypes.number, // the max value
    sortDesc    : React.PropTypes.bool, // the indicator sort order [indicator.order === 'DESC']
	},
  
  getInitialState: function () {

    return {
      styles:{ 
        ref : {
          active:{
            stroke:'#333',
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#666',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        top : {          
          active:{
            stroke:getDataColour(true),
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#aaa',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        bottom : {
          active:{
            stroke:getDataColour(false),
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#aaa',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        range : {
          active:{
            stroke:'#333',
            strokeOpacity:0.3,
            strokeWidth:10
          },
          inactive:{
            stroke:'#333',
            strokeOpacity:0.15,
            strokeWidth:10
          },
        }
     }
    }
  },

          
 
  componentDidMount : function() {
   
  },     
  componentWillUnmount : function() {
   
  },          
  render: function () {
		log('props', this.props)
    var height = 300
    // remove partial group averages    
    var data = _.filter(this.props.data, function(d){
        return _(this.props.breakdowns).every(function(bd){return d[bd.id] !== 'all'}) 
          ||   _(this.props.breakdowns).every(function(bd){return d[bd.id] === 'all'})
      },this)  

    
    var highlightGroups = this.props.highlightGroups
    var datasetCurrent = {}
    // add top/bottom groups if range is active
    if (this.props.highlightDatasets.length > 0){
      datasetCurrent = _.findWhere(this.props.datasets,{id:this.props.highlightDatasets[0]})
      data = data.concat(datasetCurrent.range.topSeries)
      data = data.concat(datasetCurrent.range.bottomSeries)     
      
      highlightGroups.push(this.getGroupProperties(datasetCurrent.range.top))
      highlightGroups.push(this.getGroupProperties(datasetCurrent.range.bottom))
      
    }
    
    // one line for each group
    var dataByGroup = this.parseGroups(data,highlightGroups)
    
    
    // set style      
    var refDatum = getReference( 
            _.filter(this.props.data,function(d){
              return d.dataset === this.props.datasets[0].id
            },this), this.props.indicator) 
    dataByGroup = _.map(dataByGroup,function(g){
      return this.style(g,refDatum)
    },this)    
    if (dataByGroup.length === 1) {
      dataByGroup[0].style = this.state.styles.bottom.active
    } else {
      
      //move active elements to bac of the array    
      var activeGroups = _.where(dataByGroup,{state:'active'})
      dataByGroup = _.reject(dataByGroup,{state:'active'}).concat(activeGroups)      
    }    
    
    // one bar for each range
    var rangesByDate = _.sortBy(this.parseDatasets(this.props.datasets),'date')
   
    
    // scales
    // warning needs to be in years
    var startDate = _.clone(_.last(rangesByDate).data[0].date)
    startDate.setMonth(startDate.getMonth()-1) 
    var endDate = _.clone(_.first(rangesByDate).data[0].date)
    endDate.setMonth(endDate.getMonth()+1)     
    
    var scales ={
      x : d3.time.scale().domain([startDate,endDate]),
      y : d3.scale.linear().domain([0,this.props.valueScale])
    }
    
    var labels = this.makeLabels(dataByGroup,scales.y.range([height,0]),datasetCurrent)
    var valueAxisLabels = this.makeValueAxisLabels(this.props.valueScale)
    
    return (
      <Row>
        <Col md={9}>
          <div style={{marginLeft:50,marginBottom:50}}>
            <LineBarChart
              flux={this.props.flux}
              data={data}
              height = {height}
              scales = {scales}
              lineData={dataByGroup}
              barData={rangesByDate}
              valueAxisLabels={valueAxisLabels}
              valueAxisWidth={50}
            />
          </div>
        </Col>
        <Col md={3}>
          <div style={{position:"relative"}}>
            {
              _.map(labels,function(label){
                return (
                  <div style={{position:'absolute',top:label.offset,color:label.colour}}>
                    <div className={'line-chart-ylabel'} style={{transform:'translate(0,-50%)'}}>
                      { 
                        (label.labelRange !== '') 
                        ? <div class="label-range"><strong>{label.labelRange}</strong></div>
                        : <span/>
                      }
                      <div>{label.label}</div>
                    </div>
                  </div>
                )
              })
            }     
          </div>
        </Col>
      </Row>
    )
		
  },
  makeLabels : function(dataByGroup,yscale,datasetCurrent){
    return _.map(_.filter(dataByGroup,function(g){return g.state==='active'}),function(g){
      // check if range value      
      var labelRange = ''
      if (typeof datasetCurrent.range !== 'undefined') {
        if (_.isEqual(g.groupProperties, this.getGroupProperties(datasetCurrent.range.top))) {
          labelRange = 'Least vulnerable group, ' + datasetCurrent.observationdate.getFullYear()
        } else if (_.isEqual(g.groupProperties,  this.getGroupProperties(datasetCurrent.range.bottom))) {
          labelRange  = 'Most vulnerable group, ' + datasetCurrent.observationdate.getFullYear()
        } 
      }
      return {
        labelRange : labelRange,
        label : g.label,
        colour: g.style.stroke,
        offset : yscale(_.last(g.data).y)
      }
    },this)
  },
  makeValueAxisLabels : function(valueScale){
    var interval
    if (valueScale <= 0.5) {
      interval = 0.1
    } else if (valueScale <= 1) {
      interval = 0.2
    } else if (valueScale <= 2.5) {                            
      interval = 0.5    
    } else if (valueScale <= 5) {                            
      interval = 1
    } else if (valueScale <= 10) {          
      interval = 2
    } else if (valueScale <= 25) {          
      interval = 5
    } else if (valueScale <= 50) {
      interval = 10
    } else if (valueScale <= 100) {
      interval = 20 
    } else if (valueScale <= 250) {          
      interval = 50
    } else if (valueScale <= 500) {
      interval = 100
    } else if (valueScale <= 1000) {                            
      interval = 200
    } else if (valueScale <= 2500) {          
      interval = 500      
    } else if (valueScale <= 5000) {          
      interval = 1000
    } else if (valueScale <= 10000) {
      interval = 2000
    } else if (valueScale <= 25000) {          
      interval = 5000
    } else if (valueScale <= 50000) {
      interval = 10000
    } else if (valueScale <= 100000) {
      interval = 20000
    } else {
      interval = 100000
    }   
    var ticks = []
    for (var i = 0; i <= valueScale;i+=interval){
      ticks.push({
        value:i,
        label:makeDataLabel(i,'',this.props.indicator.unit,false,true)
      })
    }
    return ticks
        
  },
    
  
  parseGroups : function(data,highlightGroups){
    var breakdownIds = 
            this.props.highlightDatasets.length > 0 
                ? this.props.indicator.breakdowns.split(',') 
                : _.pluck(this.props.breakdowns,'id')
    var groups = []
    _.each(data,function(d){
      var groupProperties = this.getGroupProperties(d)
      var groupsFiltered = _.filter(groups, function(g){return _.isEqual(g.groupProperties,groupProperties)})
      // if group not in groups add to groups with data
      if (groupsFiltered.length === 0 ) {
        groups.push({
          groupProperties : groupProperties,
          label : makeGroupLabel(this.props.flux,breakdownIds,d), 
          state : this.isGroupActive(groupProperties,highlightGroups) ? 'active' : 'inactive',
          data : [{
              date:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
              y:d.value,
              label:makeDataLabel(d.value,this.props.indicator.datatype,this.props.indicator.unit,false,true),
              datum:d
          }]
        })
      } else {
        groupsFiltered[0].data.push({
          date:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
          y:d.value,
          label:makeDataLabel(d.value,this.props.indicator.datatype,this.props.indicator.unit,false,true),          
          datum:d
        })
      }
      
      
    },this)
    
    return _.map(groups,function(g){
      g.data = _.sortBy(g.data,'date')
      return g
    })
    
  },


  parseDatasets : function(datasets){
    return _.map(datasets,function(dataset){
      return {
        data: [{
            date:dataset.observationdate,
            y:dataset.range.top.value
          },
          {
            date:dataset.observationdate,
            y:dataset.range.bottom.value
          }],
        style : this.state.styles.range[this.isDatasetActive(dataset.id) ? 'active' : 'inactive'],
        id : dataset.id
      }
    },this)
  },
    
  style : function(g,refDatum){
    var state = g.state

    if (typeof refDatum.value !== 'undefined') {
      var val = _.last(_.sortBy(g.data,'x')).y          
      if (val > refDatum.value){            
        g.style = this.state.styles[(this.props.sortDesc ? 'bottom' : 'top')][state]
      } else if (val < refDatum.value){
        g.style = this.state.styles[(this.props.sortDesc ? 'top' : 'bottom')][state]
      } else {
        // there must be a better way to check equality with ref datum
        if (_.isEqual(g.groupProperties,this.getGroupProperties(refDatum))){
          g.style = this.state.styles.ref[state]
        } else {
          g.style = this.state.styles.bottom[state]
        }
      }
    } else {
      g.style = this.state.styles.bottom[state]
    }
    return g
  },  
          
  getGroupProperties : function(datum){
    return _.map(this.props.indicator.breakdowns.split(','),function(bd){        
      return datum[bd]
    })
  },
  isGroupActive : function(groupProperties,highlightGroups){
    return _.filter(highlightGroups, function(g){return _.isEqual(g,groupProperties)}).length > 0
  },
  isDatasetActive : function(datasetId){
    // compare date
    return this.props.highlightDatasets.indexOf(datasetId) > -1
  },
  
          
          


})
