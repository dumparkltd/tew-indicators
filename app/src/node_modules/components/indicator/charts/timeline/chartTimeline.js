//main
var React       = require('react')


var makeGroupLabel = require('utils/makeGroupLabel')

//helpers
var _ 					= require('lodash')



//logging
var log       	= require('debug')('components:indicator:timeline')



module.exports = React.createClass({

	propTypes : {
    flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // tehc urrent indicator
    datasets    : React.PropTypes.object, // datasets/timesteps
    breakdowns  : React.PropTypes.array, // breakdowns
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')    
    axisScale   : React.PropTypes.number, // the max value
    sortDesc    : React.PropTypes.bool, // the indicator sort order [indicator.order === 'DESC']
	},
  
  getInitialState: function () {

    return {
      parentWidth: 0,
      highlightGroups:[],//[['15-24','m'],['15-24','f']],
      highlightDatasets:[]//['HLFS1409']
    }
  },

  getDefaultProps() {
      return {
          width: '100%',
          height: 300,
          margin: { left: -1, top: 10, bottom: 0, right: 1 }
      }
  },
          
  handleWindowResize(e) {
      var elem = this.getDOMNode();
      var width = elem.offsetWidth;

      this.setState({
          parentWidth: width
      });
  },
  componentDidMount() {
    if(this.props.width === '100%') {
        window.addEventListener('resize', this.handleWindowResize);
    }
    this.handleWindowResize();
  },     
  componentWillUnmount() {
    if(this.props.width === '100%') {
        window.removeEventListener('resize', this.handleWindowResize);
    }
  },          
  render: function () {
		log('props', this.props)
    var width = this.props.width
    // Determine the right graph width to use if it's set to be responsive
      if(width === '100%') {
        width = this.state.parentWidth || 400;
      }
    
    // remove partial group averages    
    var data = _.filter(this.props.data, function(d){
        return _(this.props.breakdowns).every(function(bd){return d[bd.id] !== 'all'}) 
          ||   _(this.props.breakdowns).every(function(bd){return d[bd.id] === 'all'})
      },this)  
    
    // one line for each group
    var dataByGroup = this.parseGroups(data)
    
    var refDatum = this.referenceDatum() 
    
    // compare with reference
    if (typeof refDatum.value !== 'undefined') {
      dataByGroup = _.map(dataByGroup, function(g){
        var isHigher = _.last(_.sortBy(g.data,'x')).y > refDatum.value
        g.top = this.props.sortDesc ? !isHigher : isHigher
        return g
      },this)
    }
    // one bar for each range
    var rangeByDate = this.parseDatasets(this.props.datasets)
    
    // Set scale ranges
//        xScale && xScale.range([0, width - (margin.left + margin.right)]);
//        yScale && yScale.range([height - (margin.top + margin.bottom), 0]);
    
    return (
        <div>{ width }
        </div>
    )
		
  },
  referenceDatum : function(){
    if (this.props.indicator.datatype === 'disfactor') {
      return {value:1}
    } else if (this.props.indicator.datatype === 'categorical' || this.props.indicator.datatype === 'absolute' ) {
      // temporary
      return {value:undefined}
    } else {

      var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
      // filter data by "all" for all breakdowns
      // TODO check for datasets that do not have "All people" average
      var ref = _.findWhere(
        _.filter(this.props.data,function(d){return d.dataset === this.props.datasets[0].id},this),
        _.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all'))
      )
      return (typeof ref !== 'undefined') ? ref : {value:undefined}
    }
  },          
  parseGroups : function(data){
    var groups = []
    _.each(data,function(d){
      var groupProperties = this.getGroupProperties(d)
      var groupsFiltered = _.filter(groups, function(g){return _.isEqual(g.group,groupProperties)})
      // if group not in groups add to groups with data
      if (groupsFiltered.length === 0 ) {
        groups.push({
          group : groupProperties,
          active : this.isGroupActive(groupProperties),
          label : makeGroupLabel(this.props.flux,_.pluck(this.props.breakdowns,'id'),d),
          top : false,
          data : [{
              x:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
              y:d.value,
              datum:d
          }]
        })
      } else {
        groupsFiltered[0].data.push({
          x:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
          y:d.value,
          datum:d
        })
      }
      
      
    },this)
    return groups
  },
  
  parseDatasets : function(datasets){
    return _.map(datasets,function(dataset){
      return {
        x:dataset.observationdate,
        y:[dataset.range.top.value, dataset.range.bottom.value],
        active : this.state.highlightDatasets.indexOf(dataset.id) > -1,
        groups:[this.getGroupProperties(dataset.range.top), this.getGroupProperties(dataset.range.bottom)],
        data:[dataset.range.top, dataset.range.bottom]
      }
    },this)
  },
  getGroupProperties : function(datum){
    return _.map(this.props.breakdowns,function(bd){        
      return datum[bd.id]
    })
  },
  isGroupActive : function(groupProperties){
    return _.filter(this.state.highlightGroups, function(g){return _.isEqual(g,groupProperties)}).length > 0
  },
  
          
          


})
