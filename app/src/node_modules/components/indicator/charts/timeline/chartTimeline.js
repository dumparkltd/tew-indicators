//main
var React       = require('react')


var makeGroupLabel = require('utils/makeGroupLabel')
var getDataColour   = require('utils/getDataColour')

//helpers
var _ 					= require('lodash')

var d3          = require('d3')
var Row 								= require('react-bootstrap/lib/Row')
var Col           			= require('react-bootstrap/lib/Col')
var LineBarChart = require('./lineBarChart')

//logging
var log       	= require('debug')('components:indicator:timeline')



module.exports = React.createClass({

	propTypes : {
    flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // tehc urrent indicator
    datasets    : React.PropTypes.array, // datasets/timesteps
    breakdowns  : React.PropTypes.array, // breakdowns
    highlightGroups  : React.PropTypes.array, // breakdowns
    highlightDatasets : React.PropTypes.array, // breakdowns
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')    
    axisScale   : React.PropTypes.number, // the max value
    sortDesc    : React.PropTypes.bool, // the indicator sort order [indicator.order === 'DESC']
	},
  
  getInitialState: function () {

    return {
      styles:{ 
        ref : {
          active:{
            stroke:'#333',
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#666',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        top : {          
          active:{
            stroke:getDataColour(true),
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#aaa',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        bottom : {
          active:{
            stroke:getDataColour(false),
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#aaa',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        range : {
          active:{
            stroke:'#333',
            strokeOpacity:0.3,
            strokeWidth:10
          },
          inactive:{
            stroke:'#333',
            strokeOpacity:0.15,
            strokeWidth:10
          },
        }
     }
    }
  },

          
 
  componentDidMount() {
   
  },     
  componentWillUnmount() {
   
  },          
  render: function () {
		log('props', this.props)
    var height = 300
    // remove partial group averages    
    var data = _.filter(this.props.data, function(d){
        return _(this.props.breakdowns).every(function(bd){return d[bd.id] !== 'all'}) 
          ||   _(this.props.breakdowns).every(function(bd){return d[bd.id] === 'all'})
      },this)  

    
    var highlightGroups = this.props.highlightGroups
    
    // add top/bottom groups if range is active
    if (this.props.highlightDatasets.length > 0){
      var range = _.findWhere(this.props.datasets,{id:this.props.highlightDatasets[0]}).range
      data = data.concat(range.topSeries)
      data = data.concat(range.bottomSeries)     
      
      highlightGroups.push(this.getGroupProperties(range.top))
      highlightGroups.push(this.getGroupProperties(range.bottom))
      
    }
    
    // one line for each group
    var dataByGroup = this.parseGroups(data,highlightGroups)
    
    
    // set style      
    var refDatum = this.referenceDatum() 
    dataByGroup = _.map(dataByGroup,function(g){
      return this.style(g,refDatum)
    },this)    
    if (dataByGroup.length === 1) {
      dataByGroup[0].style = this.state.styles.bottom.active
    } else {
      
      //move active elements to bac of the array    
      var activeGroups = _.where(dataByGroup,{state:'active'})
      dataByGroup = _.reject(dataByGroup,{state:'active'}).concat(activeGroups)      
    }    
    
    // one bar for each range
    var rangesByDate = _.sortBy(this.parseDatasets(this.props.datasets),'date')
   
    
    // scales
    // warning needs to be in years
    var startDate = _.clone(_.last(rangesByDate).data[0].date)
    startDate.setMonth(startDate.getMonth()-1) 
    var endDate = _.clone(_.first(rangesByDate).data[0].date)
    endDate.setMonth(endDate.getMonth()+1)     
    
    var scales ={
      x : d3.time.scale().domain([startDate,endDate]),
      y : d3.scale.linear().domain([0,this.props.axisScale])
    }
    
    var labels = this.makeLabels(dataByGroup,scales.y.range([height,0]))
    
    return (
      <Row>
        <Col md={9}>
          <div>
            <LineBarChart
              flux={this.props.flux}
              data={data}
              height = {height}
              scales = {scales}
              lineData={dataByGroup}
              barData={rangesByDate}
            />
          </div>
        </Col>
        <Col md={3}>
          <div style={{position:"relative"}}>
            {
              _.map(labels,function(label){
                return (
                  <div style={{position:'absolute',top:label.offset}}>
                    <div className={'line-chart-ylabel'} style={{transform:'translate(0,-50%)'}}>
                      {label.label}
                    </div>
                  </div>
                )
              })
            }     
          </div>
        </Col>
      </Row>
    )
		
  },
  makeLabels : function(dataByGroup,yscale){
    return _.map(_.filter(dataByGroup,function(g){return g.state==='active'}),function(g){
      return {
        label : g.label,
        offset : yscale(_.last(g.data).y)
      }
    })
  },
  referenceDatum : function(){
     
    if (this.props.indicator.datatype === 'disfactor') {
        return {value:1}
    } else if (this.props.indicator.datatype === 'part-to-whole' && this.props.breakdowns.length === 1 && this.props.breakdowns[0].id === 'sex') {
      return {value: 0.5}
    } else if (this.props.indicator.datatype === 'categorical' || this.props.indicator.datatype === 'absolute' ) {
      // temporary
      return {value:undefined}
    } else {
      var breakdowns = this.props.indicator.breakdowns.split(',')
      // warning all available breakdowns not the ordered breakdowns
      // filter data by "all" for all breakdowns
      // TODO check for datasets that do not have "All people" average
      var ref = _.findWhere(
        _.filter(this.props.data,function(d){return d.dataset === this.props.datasets[0].id},this),
        _.zipObject(breakdowns,_.fill(Array(breakdowns.length), 'all'))
      )
      if (typeof ref !== 'undefined') {
        ref.label = this.props.indicator.referencelabel
      } else {
        ref = {value:undefined}
      }
      
      
      return  ref 
    }
  },  
  
  parseGroups : function(data,highlightGroups){
    var breakdownIds = 
            this.props.highlightDatasets.length > 0 
                ? this.props.indicator.breakdowns.split(',') 
                : _.pluck(this.props.breakdowns,'id')
    var groups = []
    _.each(data,function(d){
      var groupProperties = this.getGroupProperties(d)
      var groupsFiltered = _.filter(groups, function(g){return _.isEqual(g.groupProperties,groupProperties)})
      // if group not in groups add to groups with data
      if (groupsFiltered.length === 0 ) {
        groups.push({
          groupProperties : groupProperties,
          label : makeGroupLabel(this.props.flux,breakdownIds,d), 
          state : this.isGroupActive(groupProperties,highlightGroups) ? 'active' : 'inactive',
          data : [{
              date:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
              y:d.value,
              datum:d
          }]
        })
      } else {
        groupsFiltered[0].data.push({
          date:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
          y:d.value,
          datum:d
        })
      }
      
      
    },this)
    
    return _.map(groups,function(g){
      g.data = _.sortBy(g.data,'date')
      return g
    })
    
  },


  parseDatasets : function(datasets){
    return _.map(datasets,function(dataset){
      return {
        data: [{
            date:dataset.observationdate,
            y:dataset.range.top.value
          },
          {
            date:dataset.observationdate,
            y:dataset.range.bottom.value
          }],
        style : this.state.styles.range[this.isDatasetActive(dataset.id) ? 'active' : 'inactive'],
        id : dataset.id
      }
    },this)
  },
    
  style : function(g,refDatum){
    var state = g.state

    if (typeof refDatum.value !== 'undefined') {
      var val = _.last(_.sortBy(g.data,'x')).y          
      if (val > refDatum.value){            
        g.style = this.state.styles[(this.props.sortDesc ? 'bottom' : 'top')][state]
      } else if (val < refDatum.value){
        g.style = this.state.styles[(this.props.sortDesc ? 'top' : 'bottom')][state]
      } else {
        // there must be a better way to check equality with ref datum
        if (_.isEqual(g.groupProperties,this.getGroupProperties(refDatum))){
          g.style = this.state.styles.ref[state]
        } else {
          g.style = this.state.styles.bottom[state]
        }
      }
    } else {
      g.style = this.state.styles.bottom[state]
    }
    return g
  },  
          
  getGroupProperties : function(datum){
    return _.map(this.props.indicator.breakdowns.split(','),function(bd){        
      return datum[bd]
    })
  },
  isGroupActive : function(groupProperties,highlightGroups){
    return _.filter(highlightGroups, function(g){return _.isEqual(g,groupProperties)}).length > 0
  },
  isDatasetActive : function(datasetId){
    // compare date
    return this.props.highlightDatasets.indexOf(datasetId) > -1
  },
  
          
          


})
