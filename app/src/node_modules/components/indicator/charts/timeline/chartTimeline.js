//main
var React       = require('react')


var makeGroupLabel = require('utils/makeGroupLabel')
var makeDataLabel = require('utils/makeDataLabel')
var getDataColor   = require('utils/getDataColor')
var getReference   = require('utils/getReference')

//helpers
var _ 					= require('lodash')

var d3          = require('d3')
var Row 								= require('react-bootstrap/lib/Row')
var Col           			= require('react-bootstrap/lib/Col')
var LineBarChart = require('./lineBarChart')

//logging
var log       	= require('debug')('components:indicator:timeline')



module.exports = React.createClass({

	propTypes : {
    flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // tehc urrent indicator
    datasets    : React.PropTypes.array, // datasets/timesteps
    breakdowns  : React.PropTypes.array, // breakdowns
    highlightGroups  : React.PropTypes.array, // breakdowns
    highlightDatasets : React.PropTypes.array, // breakdowns
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')
    valueScale   : React.PropTypes.number, // the max value
    sortDesc    : React.PropTypes.bool, // the indicator sort order [indicator.order === 'DESC']
	},

  getInitialState: function () {

    return {
      styles:{
        ref : {
          active:{
            stroke:'#333',
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#666',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        top : {
          active:{
            stroke:getDataColor(true),
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#aaa',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        bottom : {
          active:{
            stroke:getDataColor(false),
            strokeOpacity:1,
            strokeWidth:2
          },
          inactive:{
            stroke:'#aaa',
            strokeOpacity:1,
            strokeWidth:1
          },
        },
        range : {
          active:{
            stroke:'#333',
            strokeOpacity:0.3,
            strokeWidth:10
          },
          inactive:{
            stroke:'#333',
            strokeOpacity:0.15,
            strokeWidth:10
          },
        }
     }
    }
  },

               
  render: function () {
		log('props', this.props)
    var height = 333
    // remove partial group averages    
    var data = _.filter(this.props.data, function(d){
        return _(this.props.breakdowns).every(function(bd){return d[bd.id] !== 'all'})
          ||   ( this.props.indicator.datatype !== 'absolute' // remove all people values (aggregate) for absolute indicators
                && _(this.props.breakdowns).every(function(bd){return d[bd.id] === 'all'}))
      },this)


    var highlightGroups = this.props.highlightGroups
    var datasetCurrent = {}
    // add top/bottom groups if range is active
    if (this.props.highlightDatasets.length > 0){
      datasetCurrent = _.findWhere(this.props.datasets,{id:this.props.highlightDatasets[0]})
      data = data.concat(datasetCurrent.range.topSeries)
      data = data.concat(datasetCurrent.range.bottomSeries)

      highlightGroups.push(this.getGroupProperties(datasetCurrent.range.top))
      highlightGroups.push(this.getGroupProperties(datasetCurrent.range.bottom))

    }

    // one line for each group
    var dataByGroup = this.parseGroups(data,highlightGroups)


    // set style
    var refDatum = getReference(
            _.filter(this.props.data,function(d){
              return d.dataset === this.props.datasets[0].id
            },this), this.props.indicator)
    dataByGroup = _.map(dataByGroup,function(g){
      return this.style(g,refDatum)
    },this)
    if (dataByGroup.length === 1) {
      dataByGroup[0].style = this.state.styles.bottom.active
    } else {

      //move active elements to bac of the array
      var activeGroups = _.where(dataByGroup,{state:'active'})
      dataByGroup = _.reject(dataByGroup,{state:'active'}).concat(activeGroups)
    }

    // one bar for each range
    var rangesByDate = _.sortBy(this.parseDatasets(this.props.datasets),'date')


    // scales
    // warning needs to be in years
    var startDate = _.clone(_.last(rangesByDate).data[0].date)
    startDate.setMonth(startDate.getMonth() - 1)
    var endDate = _.clone(_.first(rangesByDate).data[0].date)
    endDate.setMonth(endDate.getMonth() + 1)

    var scales = {
      x : d3.time.scale().domain([startDate,endDate]),
      y : d3.scale.linear().domain([0,this.props.valueScale])
    }

    var labels = this.makeLabels(dataByGroup,scales.y.range([height,0]),datasetCurrent)
    var valueAxisLabels = this.makeValueAxisLabels(this.props.valueScale)

    return (
      <div>
      <div className="line-chart-header">
        <div className="line-chart-key key line-chart-key-primary">
        { 
          (this.hasReference(refDatum)) ? this.renderKey() : ''              
        }
        </div>  
        <div className="line-chart-key key line-chart-key-secondary clearfix">
        {  this.renderKeyLower()}
        </div>  
        <Row className="line-chart-hint">
          <Col md={9}  xs={9}>
            Hover over the lines to explore data for individual groups
          </Col>
        </Row>
      </div>            
      <Row>
        <Col md={9} xs={9} className="line-chart-main">
          <div className="line-chart-body" style={{marginLeft:50,marginBottom:50}}>
            <LineBarChart
              flux={this.props.flux}
              data={data}
              height = {height}
              scales = {scales}
              lineData={dataByGroup}
              barData={rangesByDate}
              valueAxisLabels={valueAxisLabels}
              valueAxisWidth={50}
            />
          </div>
        </Col>
        <Col className="line-chart-aside" md={3}  xs={3}>
          <div style={{position:"relative"}}>
            {
              _.map(labels,function(label){
                
                var translate = -50
                if (label.labelRange !== '') {
                  if (label.isAbove) {                  
                    translate = -100
                  } else {
                    translate = 0
                  }
                }
                translate = 'translate(0,'+translate.toString()+'%)'
                
                return (
                  <div style={{position:'absolute',top:label.offset,color:label.color}}>
                    <div 
                      className={(label.labelRange !== '') 
                        ? 'line-chart-ylabel line-chart-ylabel-range ' + (label.isAbove? ' line-chart-ylabel-range-above' :  'line-chart-ylabel-range-below')
                        : 'line-chart-ylabel'}                       
                      style={{
                          WebkitTransform:translate,
                          MozTransform:translate,
                          transform:translate
                        }}>
                      {
                        (label.labelRange !== '')
                        ? <div className="label-range"><strong>{label.labelRange}</strong></div>
                        : null
                      }
                      { 
                        (label.labelRange !== '') 
                        ? <div>{label.label}</div>
                        : <div><strong>{label.label}</strong></div>
                      }              
                      
                    </div>
                  </div>
                )
              })
            }
          </div>
        </Col>
      </Row>
      </div>
    )

  },
  hasReference : function(refDatum){
    return (typeof refDatum.value !== 'undefined')
  },
  renderKey : function(){
    return (
            <div className="key-wrapper" >
              <div className="key-top" >
                <div className="key-label" >Less marginalised</div>
                <div className="key-symbol">
                  <span style={{backgroundColor:getDataColor(true)}}></span>
                </div>
              </div>
              <div className="key-bottom" >
                <div className="key-label" >More marginalised</div>
                <div className="key-symbol">
                  <span style={{backgroundColor:getDataColor(false)}}></span>
                </div>
              </div>
            </div>
    )
  },
  renderKeyLower : function(){
    return (
            <div className="key-wrapper" >
              <div className="key-label" >Range of all groups</div>
              <div className="key-symbol">
                <span style={{backgroundColor:this.state.styles.range.inactive.stroke,opacity:this.state.styles.range.inactive.strokeOpacity}}></span>
              </div>
            </div>
    )
  },
  
  makeLabels : function(dataByGroup,yscale,datasetCurrent){
    return _.map(_.filter(dataByGroup,function(g){return g.state === 'active'}),function(g){
      // check if range value
      var labelRange = ''
      var isAbove = false
      if (typeof datasetCurrent.range !== 'undefined') {
        if (_.isEqual(g.groupProperties, this.getGroupProperties(datasetCurrent.range.top))) {
          labelRange = 'Least marginalised group, ' + datasetCurrent.observationdate.getFullYear()
          isAbove = !this.props.sortDesc
        } else if (_.isEqual(g.groupProperties,  this.getGroupProperties(datasetCurrent.range.bottom))) {
          labelRange  = 'Most marginalised group, ' + datasetCurrent.observationdate.getFullYear()
          isAbove = this.props.sortDesc
        } 
      }
      return {
        labelRange : labelRange,
        label : g.label,
        color: g.style.stroke,
        offset : yscale(_.last(g.data).y),
        isAbove : isAbove
      }
    },this)
  },
  makeValueAxisLabels : function(valueScale){
    var interval
    if (valueScale <= 0.5) {
      interval = 0.1
    } else if (valueScale <= 1) {
      interval = 0.2
    } else if (valueScale <= 2.5) {
      interval = 0.5
    } else if (valueScale <= 5) {
      interval = 1
    } else if (valueScale <= 10) {
      interval = 2
    } else if (valueScale <= 25) {
      interval = 5
    } else if (valueScale <= 50) {
      interval = 10
    } else if (valueScale <= 100) {
      interval = 20
    } else if (valueScale <= 250) {
      interval = 50
    } else if (valueScale <= 500) {
      interval = 100
    } else if (valueScale <= 1000) {
      interval = 200
    } else if (valueScale <= 2500) {
      interval = 500
    } else if (valueScale <= 5000) {
      interval = 1000
    } else if (valueScale <= 10000) {
      interval = 2000
    } else if (valueScale <= 25000) {
      interval = 5000
    } else if (valueScale <= 50000) {
      interval = 10000
    } else if (valueScale <= 100000) {
      interval = 20000
    } else {
      interval = 100000
    }
    var ticks = []
    for (var i = 0; i <= valueScale; i += interval){
      ticks.push({
        value:i,
        label:makeDataLabel(i,'',this.props.indicator.unit,true,true)
      })
    }
    return ticks

  },


  parseGroups : function(data,highlightGroups){
    var breakdownIds =
            this.props.highlightDatasets.length > 0
                ? this.props.indicator.breakdowns.split(',')
                : _.pluck(this.props.breakdowns,'id')
    var groups = []
    _.each(data,function(d){
      var groupProperties = this.getGroupProperties(d)
      var groupsFiltered = _.filter(groups, function(g){return _.isEqual(g.groupProperties,groupProperties)})
      // if group not in groups add to groups with data
      if (groupsFiltered.length === 0 ) {
        groups.push({
          groupProperties : groupProperties,
          label : makeGroupLabel(this.props.flux,breakdownIds,d),
          state : this.isGroupActive(groupProperties,highlightGroups) ? 'active' : 'inactive',
          data : [{
              date:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
              y:d.value,
              label:makeDataLabel(d.value,this.props.indicator.datatype,this.props.indicator.unit,false,true),
              datum:d
          }]
        })
      } else {
        groupsFiltered[0].data.push({
          date:_.findWhere(this.props.datasets,{id : d.dataset}).observationdate,
          y:d.value,
          label:makeDataLabel(d.value,this.props.indicator.datatype,this.props.indicator.unit,false,true),
          datum:d
        })
      }


    },this)

    return _.map(groups,function(g){
      g.data = _.sortBy(g.data,'date')
      return g
    })

  },


  parseDatasets : function(datasets){
    return _.map(datasets,function(dataset){
      return {
        data: [{
            date:dataset.observationdate,
            y:dataset.range.top.value
          },
          {
            date:dataset.observationdate,
            y:dataset.range.bottom.value
          }],
        style : this.state.styles.range[this.isDatasetActive(dataset.id) ? 'active' : 'inactive'],
        id : dataset.id
      }
    },this)
  },

  style : function(g,refDatum){
    var state = g.state

    if (typeof refDatum.value !== 'undefined') {
      var val = _.last(_.sortBy(g.data,'x')).y
      if (val > refDatum.value){
        g.style = this.state.styles[(this.props.sortDesc ? 'bottom' : 'top')][state]
      } else if (val < refDatum.value){
        g.style = this.state.styles[(this.props.sortDesc ? 'top' : 'bottom')][state]
      } else {
        // there must be a better way to check equality with ref datum
        if (_.isEqual(g.groupProperties,this.getGroupProperties(refDatum))){
          g.style = this.state.styles.ref[state]
        } else {
          g.style = this.state.styles.bottom[state]
        }
      }
    } else {
      g.style = this.state.styles.bottom[state]
    }
    return g
  },

  getGroupProperties : function(datum){
    return _.map(this.props.indicator.breakdowns.split(','),function(bd){
      return datum[bd]
    })
  },
  isGroupActive : function(groupProperties,highlightGroups){
    return _.filter(highlightGroups, function(g){return _.isEqual(g,groupProperties)}).length > 0
  },
  isDatasetActive : function(datasetId){
    // compare date
    return this.props.highlightDatasets.indexOf(datasetId) > -1
  },





})
