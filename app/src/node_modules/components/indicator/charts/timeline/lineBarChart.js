//main
var React       = require('react')

//helpers
var _ 					= require('lodash')

var d3          = require('d3')
//var Line        = require('./line')
//logging
var log       	= require('debug')('components:indicator:lineBarChart')



module.exports = React.createClass({

	propTypes : {
    flux        : React.PropTypes.object,
    data        : React.PropTypes.array,
    lineData    : React.PropTypes.array,
    barData     : React.PropTypes.array,
    width       : React.PropTypes.string,
    height      : React.PropTypes.number,
    scales      : React.PropTypes.object,
	},
  
  getInitialState: function () {

    return {
      parentWidth: 0,
          success: false
    }
  },

  getDefaultProps() {
      return {
          width: '100%',
          height: 300
      }
  },
          
  handleWindowResize(e) {
      var elem = this.getDOMNode();
      var width = elem.offsetWidth;

      this.setState({
          parentWidth: width
      });
  },
  componentDidMount() {
    if(this.props.width === '100%') {
        window.addEventListener('resize', this.handleWindowResize);
    }
    this.handleWindowResize();
  },     
  componentWillUnmount() {
    if(this.props.width === '100%') {
        window.removeEventListener('resize', this.handleWindowResize);
    }
  },          
  render: function () {
		log('props', this.props)
    var width = this.props.width
    var height = this.props.height
    // Determine the right graph width to use if it's set to be responsive
    if(width === '100%') {
      width = this.state.parentWidth || 400;
    }     
    // create x and y scales that map the chart dimensions to the min/max x and y values in the data
    var xMin = 0, 
        xMax = width, 
        yMin = height, 
        yMax = 0;
    var barData = this.props.barData
    

    var x = this.props.scales.x.range([xMin, xMax])
    var y = this.props.scales.y.range([yMin, yMax]);
    
    // line function
    var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.y); });
    
    // voronoi function
    var voronoi = d3.geom.voronoi()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.y); })
    .clipExtent([[0, 0], [width, height]]);
    
    var vnodes = _.filter(voronoi(this.flatten(this.props.lineData)),function(vnode){return typeof vnode !== 'undefined'})
    
    return (

      <div>
        <svg ref='svg' width={width} height={height} className='chart line-bar-chart'>
          <g>         
          {
            _.map(this.props.lineData,function(group){
              return (
                <g>
                <path 
                  d={line(group.data)}
                  fill={'none'}
                  strokeWidth={group.style.strokeWidth}
                  stroke={group.style.stroke}           
                />
                </g>
              )
            },this)
          }
          </g>
          <g>         
          {
            _.map(vnodes,function(vnode){
              return (

                <path    
                  onMouseOver={this.handleRegionMouseOver(vnode.point)}
                  onMouseOut={this.handleRegionMouseOut(vnode.point)}        
                  fill={'gray'}
                  opacity={0}
                  strokeWidth={0}
                  d={ this.drawPath(vnode) }
                />

              )
            },this)          
          }
          </g>
          <g>   
          {
            _.map(this.props.barData,function(dataset){
              return (
                <g>
                <path 
                  onMouseOver={this.handleRangeMouseOver(dataset.id)}
                  onMouseOut={this.handleRangeMouseOut(dataset.id)}              
                  d={line(dataset.data)}
                  fill={'none'}
                  strokeWidth={dataset.style.strokeWidth}
                  stroke={dataset.style.stroke}
                  strokeOpacity={dataset.style.strokeOpacity}
                />
                </g>
              )
            },this)
          } 
          </g>
        </svg>
      </div>

    )		

  },
  drawPath: function(d) {
    if(d === undefined) {
      return; 
    }  
    return 'M' + d.join(',') + 'Z';
  },
  flatten : function(groups){
    var flattened = []
    
    _.each(groups,function(group){
      flattened = flattened.concat(_.map(group.data,function(d){
        d.groupProperties = group.groupProperties        
        return d
      }))
    })
    return flattened
    
  },

  
  handleLineMouseOver: function (group) {    
    var self = this
    return function (e) {
      e.preventDefault()
      self.props.flux.actions.indicator.lineChart.highlightGroup(group)
    }
  },

  handleLineMouseOut: function () {
    var self = this
    return function (e) {
      e.preventDefault()
      self.props.flux.actions.indicator.lineChart.unHighlightGroup()
    } 
  },
  handleRegionMouseOver: function (point) {    
    var self = this
    return function (e) {
      e.preventDefault()
//      log('handleRegionMouseOver',point.groupProperties)
      
      self.props.flux.actions.indicator.lineChart.highlightGroup(point.groupProperties)
    }
  },

  handleRegionMouseOut: function (point) {    
    var self = this
    return function (e) {
      e.preventDefault()
//      log('handleRegionMouseOut',point.groupProperties)        
     
      self.props.flux.actions.indicator.lineChart.unHighlightGroup()
      
    } 
  },
  handleRangeMouseOver: function (datasetId) {    
    var self = this
    return function (e) {
      e.preventDefault()
      log('handleRangeMouseOver',datasetId)
      
      self.props.flux.actions.indicator.lineChart.highlightDataset(datasetId)
    }
  },

  handleRangeMouseOut: function (datasetId) {    
    var self = this
    return function (e) {
      e.preventDefault()
      log('handleRangeMouseOut',datasetId)        
     
      self.props.flux.actions.indicator.lineChart.unHighlightDataset()
      
    } 
  },
  triggerSuccess: function(arg) {
    return function(e){
      e.preventDefault()
      log('arg',arg)
    }
  }


})
