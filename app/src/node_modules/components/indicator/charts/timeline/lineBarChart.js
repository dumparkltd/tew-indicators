//main
var React       = require('react')

//helpers
var _           = require('lodash')

var d3          = require('d3')
//var Line        = require('./line')
//logging
var log         = require('debug')('components:indicator:lineBarChart')



module.exports = React.createClass({

  propTypes : {
    flux        : React.PropTypes.object,
    data        : React.PropTypes.array,
    lineData    : React.PropTypes.array,
    barData     : React.PropTypes.array,
    width       : React.PropTypes.string,
    height      : React.PropTypes.number,
    scales      : React.PropTypes.object,
    valueAxisLabels  : React.PropTypes.array,
    valueAxisWidth  : React.PropTypes.number,
  },

  getInitialState: function () {

    return {
      parentWidth: 0,
          success: false
    }
  },

  getDefaultProps : function() {
      return {
          width: '100%',
          height: 300
      }
  },

  handleWindowResize : function(e) {
      var elem = this.getDOMNode();
      var width = elem.offsetWidth;

      this.setState({
          parentWidth: width
      });
  },
  componentDidMount : function() {
    if(this.props.width === '100%') {
        window.addEventListener('resize', this.handleWindowResize);
    }
    this.handleWindowResize();
  },
  componentWillUnmount : function() {
    if(this.props.width === '100%') {
        window.removeEventListener('resize', this.handleWindowResize);
    }
  },
  render: function () {
    log('props', this.props)
    var width = this.props.width
    var height = this.props.height
    // Determine the right graph width to use if it's set to be responsive
    if(width === '100%') {
      width = this.state.parentWidth || 400;
    }
    // create x and y scales that map the chart dimensions to the min/max x and y values in the data
    var xMin = 0,
        xMax = width,
        yMin = height,
        yMax = 0;


    var x = this.props.scales.x.range([xMin, xMax])
    var y = this.props.scales.y.range([yMin, yMax]);

    // line function
    var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.y); });
    
    // only make voronoi if more than 1 line present #185
    if (this.props.lineData.length > 1) {
      


      // voronoi function
      var voronoi = d3.geom.voronoi()
      .x(function(d) { return x(d.date); })
      .y(function(d) { return y(d.y); })
      .clipExtent([[0, 0], [width, height]]);

      var steps = 4

      var interpolated = this.flatten(_.map(this.props.lineData, function (group) {
        var interpolatedGroup = _.clone(group)
        interpolatedGroup.data = this.interpolate(group.data, steps)
        return interpolatedGroup
      }, this))

      // var vnodes = _.filter(voronoi(this.flatten(this.props.lineData)), function (vnode) { return typeof vnode !== 'undefined' })
      var vnodes = _.filter(voronoi(interpolated), function (vnode) { return typeof vnode !== 'undefined' })
    } else {
      var vnodes = []
    }
    return (

      <div style={{position:'relative'}}>
        <svg ref='svg' width={width} height={height} className='chart line-bar-chart'>
          <g>
          {
            _.map(this.props.lineData,function(group){
              return (
                <g>
                <path
                  d={line(group.data)}
                  fill={'none'}
                  strokeWidth={group.style.strokeWidth}
                  stroke={group.style.stroke}
                />
                </g>
              )
            },this)
          }
          </g>
          <g>
          {
            _.map(vnodes,function(vnode){
              return (

                <path
                  onMouseOver={this.handleRegionMouseOver(vnode.point)}
                  onMouseOut={this.handleRegionMouseOut(vnode.point)}
                  fill={'gray'}
                  opacity={0}
                  strokeWidth={0}
                  d={ this.drawPath(vnode) }
                />

              )
            },this)
          }
          </g>
          <g>
          {
            _.map(this.props.barData,function(dataset){
              return (
                <g>
                <path
                  onMouseOver={this.handleRangeMouseOver(dataset.id)}
                  onMouseOut={this.handleRangeMouseOut(dataset.id)}
                  d={line(dataset.data)}
                  fill={'none'}
                  strokeWidth={dataset.style.strokeWidth}
                  stroke={dataset.style.stroke}
                  strokeOpacity={dataset.style.strokeOpacity}
                />
                </g>
              )
            },this)
          }
          </g>
          <g>
          {
            _.map(this.props.lineData,function(group){
                return _.map(group.data,function(d){
                  return (
                    <circle
                      cx={x(d.date)}
                      cy={y(d.y)}
                      r={(group.state === 'active') ? 4 : 2 }
                      fill={(group.state === 'active') ? group.style.stroke : 'gray'}
                    />
                  )
                })
              })
            }
          </g>
        </svg>
        {
          _.map(_.filter(this.props.lineData,{state:'active'}),function(group){
            return _.map(group.data,function(d){
              return (
                <div className={"line-label"} style={{position:"absolute",top:y(d.y),left:x(d.date)}}>
                  <div className={'inner'} >
                      {d.label}
                  </div>
                </div>
              )
            })
          })
        }
        <div className={'date-axis'} style={{position:"absolute",top:height,left:0}}>
          {
            _.map(this.props.barData,function(dataset){
              var d = dataset.data[0]
              return (
                <div className={"date-axis-label"} style={{position:"absolute",top:0,left:x(d.date)}}>
                  <div className={'inner'}>{d.date.getFullYear()}</div>
                </div>
              )
            })
          }
        </div>
        <div className={'value-axis'} style={{position:"absolute",top:0,left:(-1*this.props.valueAxisWidth),width:this.props.valueAxisWidth}}>
          {
            _.map(this.props.valueAxisLabels,function(tick){
              return (
                <div className={"value-axis-label"} style={{position:"absolute",top:y(tick.value),left:0}}>
                  <div className={'inner'}>{tick.label}</div>
                  <div className={'tick'}></div>
                </div>
              )
            })
          }
        </div>
      </div>

    )

  },

  drawPath: function(d) {
    if(d === undefined) {
      return;
    }
    return 'M' + d.join(',') + 'Z';
  },

  flatten : function(groups){
    var flattened = []

    _.each(groups,function(group){
      flattened = flattened.concat(_.map(group.data,function(d){
        d.groupProperties = group.groupProperties
        return d
      }))
    })
    // log('groups, flattened', groups, flattened)
    return flattened

  },

  interpolate: function (timeseries, n) {
    var interpolated = [timeseries[0]]   
    // not for the last element
    for (var i = 0; i+1 < timeseries.length; i++) {
      var current = timeseries[i]
      var next = timeseries[i+1]
      var currentUnix = current.date.valueOf()
      var nextUnix = next.date.valueOf()
      var timeStep = (nextUnix - currentUnix) / n
      var valueStep = (next.y - current.y) / n      
      
      for (var j = 1; j <= n; j++) {
        interpolated.push({
          date: new Date(currentUnix + (timeStep * j)),
          y: current.y + (valueStep * j)
        })
      }                        
    }    

    return interpolated
  },

  handleLineMouseOver: function (group) {
    var self = this
    return function (e) {
      e.preventDefault()
      self.props.flux.actions.indicator.lineChart.highlightGroup(group)
    }
  },

  handleLineMouseOut: function () {
    var self = this
    return function (e) {
      e.preventDefault()
      self.props.flux.actions.indicator.lineChart.unHighlightGroup()
    }
  },
  handleRegionMouseOver: function (point) {
    var self = this
    return function (e) {
      e.preventDefault()
//      log('handleRegionMouseOver',point.groupProperties)

      self.props.flux.actions.indicator.lineChart.highlightGroup(point.groupProperties)
    }
  },

  handleRegionMouseOut: function (point) {
    var self = this
    return function (e) {
      e.preventDefault()
//      log('handleRegionMouseOut',point.groupProperties)

      self.props.flux.actions.indicator.lineChart.unHighlightGroup()

    }
  },
  handleRangeMouseOver: function (datasetId) {
    var self = this
    return function (e) {
      e.preventDefault()
      log('handleRangeMouseOver',datasetId)

      self.props.flux.actions.indicator.lineChart.highlightDataset(datasetId)
    }
  },

  handleRangeMouseOut: function (datasetId) {
    var self = this
    return function (e) {
      e.preventDefault()
      log('handleRangeMouseOut',datasetId)

      self.props.flux.actions.indicator.lineChart.unHighlightDataset()

    }
  },
  triggerSuccess: function(arg) {
    return function(e){
      e.preventDefault()
      log('arg',arg)
    }
  }


})
