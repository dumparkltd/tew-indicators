//main
var React           = require('react')


//components
var TableHeader     = require('./chartSnapshotHeader')
var TableRow        = require('./chartSnapshotRow')

var makeGroupLabel  = require('utils/makeGroupLabel')
var makeDataLabel   = require('utils/makeDataLabel')
var getDataColor   = require('utils/getDataColor')
var getReference   = require('utils/getReference')
var cartesianProduct   = require('utils/cartesianProduct')



//helpers
var _               = require('lodash')

//logging
var log             = require('debug')('components:indicator:snapshot')


module.exports = React.createClass({

  propTypes : {
    flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // tehc urrent indicator
    dataset    : React.PropTypes.object, // datasets/timesteps
    breakdowns  : React.PropTypes.array, // breakdowns
    groups      : React.PropTypes.array, // groups for each breakdown
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')
    sortBy      : React.PropTypes.string, // one of ["group","value"]
    sortOptions : React.PropTypes.array, //
    valueScale   : React.PropTypes.number, // the max value
    sortDesc    : React.PropTypes.bool // the indicator sort order [indicator.order === 'DESC']
  },

  render: function () {
    log('props', this.props)

      var refDatum = getReference(this.props.data,this.props.indicator)
      return (

        <div className='snapshot'>
          <table key={'snapshot-' + this.props.indicator.id } className='table chart-table'>
            <TableHeader
              flux            = {this.props.flux}
              breakdowns      = {this.props.breakdowns}
              chartTitle      = {this.props.indicator.title}
              sortOptions     = {this.props.sortOptions }
              sortBy          = {this.props.sortBy}
              refDatumLabel    = {makeDataLabel(refDatum.value, this.props.indicator.datatype, this.props.indicator.unit)}
              refLength       = { refDatum.value === 0 || refDatum.value === ''
                ? 0
                : this.getBarLength(refDatum.value, this.props.valueScale)}
              refLabel        = {this.props.indicator.referencelabel}
              zeroLabel       = {makeDataLabel(0, this.props.indicator.datatype, this.props.indicator.unit)}
            />
            { this.props.sortBy === 'group'
              ? this.renderByGroup(refDatum.value)
              : this.props.sortBy === 'rank'
                ? this.renderByRank(refDatum.value)
                : this.renderByValue(refDatum.value)
            }
          </table>
        </div>
      )
  },


  // render by group ////////////////////////////////////////////////////////////////////



  renderByGroup : function(refValue){
    log('refValue', refValue)
    var maxValue = this.props.valueScale

    // remove average values
    var breakdowns = this.props.breakdowns
    var indicator = this.props.indicator

    this.previousGroups = {}
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })
            }).value()
    var groupProduct = cartesianProduct(this.props.groups)

    return (
      <tbody className='table-body'>
        {
          _.map(groupProduct,function(group){
            //get the datum
            var filter = {}
            _.each(group,function(row){
              filter[row.breakdown] = row.short
            })

            var datum = _(data).filter(filter).value()
            var className = ''
            if (typeof datum !== 'undefined' && datum.length) {
              // check for row highlight
              var highlight = this.checkHighlight(datum[0])
              className = highlight ? 'data-row row-highlight' : ''
            }

            // figure out group configuration
            var currentGroups = _(group).map(function(attr){
                      return [attr.breakdown,attr.short]
                    }).zipObject().value()

            var previousGroups = this.previousGroups

            if (this.isNewGroup(previousGroups,currentGroups)) {
                className += ' new-group'
                return (
                [
                  <TableRow
                    key={group.short + '-spacer'}
                    rowData = {this.prepareRowSpacer(refValue,maxValue )}
                    className = { 'spacer' }
                  />,
                  <TableRow
                    key={group.short}
                    rowData = {this.prepareRowDataGrouped(
                      typeof datum[0] !== 'undefined' ? datum[0] : filter,
                      maxValue,
                      refValue,
                      currentGroups,
                      indicator
                      )}
                    className = { className }
                  />
                ])
            } else {
              return (
                  <TableRow
                    key={group.short}
                    rowData = {this.prepareRowDataGrouped(
                      typeof datum[0] !== 'undefined' ? datum[0] : filter,
                      maxValue,
                      refValue,
                      currentGroups,
                      indicator
                      )}
                    className = { className }
                  />
                )
            }
          },this)
        }
        { this.renderRange() }
      </tbody>
    )
  },
  renderRange : function(){
    var indicator = this.props.indicator
    if (indicator.datatype === 'categorical' || indicator.datatype === 'part-to-whole' || indicator.multidimensional === 'n') {
      return []
    } else {

      var spacer = <TableRow rowData = {this.prepareRowSpacer(0,0 )} className = { 'spacer' } />

      var top = <TableRow rowData = {this.prepareRowRangeTop()} className = { 'range' }/>

      var bottom = <TableRow rowData = {this.prepareRowRangeBottom()} className = { 'range' }/>

      return [spacer,top,bottom]
    }
  },

  isNewGroup : function(previousGroups,currentGroups){

    // new group of groups if last 2 group attributes are different
    if (_.isEmpty(previousGroups) || this.props.breakdowns.length === 1)  {
      return false
    } else {
      var isNewGroup = false
      _.each(this.props.breakdowns, function(val,index,self){

        // if last item
        if (self.length - 1 === index) {
          isNewGroup = isNewGroup || false
        } else {
          isNewGroup = isNewGroup || previousGroups[val.id] !== currentGroups[val.id]
        }

      })

      return isNewGroup
    }

  },



  // for group sorted rows
  prepareRowDataGrouped : function (datum, maxValue, refValue, currentGroups, indicator) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1

    var repeatLabel = false
    // one cell for each active dimension
    var rowData = _(this.props.breakdowns).map(function(bd){
        // get group cells
        //once different always different (for each row)
        repeatLabel =
                repeatLabel
             || typeof this.previousGroups[bd.id] === 'undefined'
             || this.previousGroups[bd.id] === ''
             || datum[bd.id] !== this.previousGroups[bd.id]

        return this.prepareLabelCell(
            (!repeatLabel)
              ? ''
              : (bd.id === 'cat')
                ? indicator.categories.split(',')[datum.cat]
                : makeGroupLabel(this.props.flux,[bd.id],datum)
          )

      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarCell(datum.value, maxValue, refValue))


    //remember groups
    this.previousGroups = currentGroups

    return rowData
  },
  prepareRowSpacer : function (refValue,maxValue) {

    // one cell for each active dimension
    var rowData = _(this.props.breakdowns).map(function(){
        return this.prepareLabelCell('')
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarSpacerCell(refValue,maxValue))

    return rowData
  },
  prepareRowRangeTop : function (){
    return [{
      type : 'range-label-top',
      colSpan : this.props.breakdowns.length,
      label : 'Least marginalised',
      color: getDataColor(true),
      className : 'group-label group-label-range group-label-range-top'
    },{
      type : 'range-bar-top',
      sortDesc : this.props.sortDesc,
      color: getDataColor(true),
      colorBottom: getDataColor(false),
      colSpan : 2,
      forceLeftAligned : (
              this.props.dataset.range.top.value < this.props.valueScale/2),
      range : {
        width: this.getRangeWidth(),
        leftOffset : this.getRangeLeftOffset(),
        value : makeDataLabel(
                this.props.dataset.range.top.value,
                this.props.indicator.datatype,
                this.props.indicator.unit
              ),
        label : makeGroupLabel(
                this.props.flux,
                this.props.indicator.breakdowns.split(','),
                this.props.dataset.range.top
              )
      }
    }]
  },
  prepareRowRangeBottom : function (){
    return [{
      type : 'range-label-bottom',
      colSpan : this.props.breakdowns.length,
      label : 'Most marginalised',
      color: getDataColor(false),
      className : 'group-label group-label-range group-label-range-bottom'
    },{
      type : 'range-bar-bottom',
      sortDesc : this.props.sortDesc,
      color: getDataColor(false),
      colSpan : 2,
      forceLeftAligned : (this.props.dataset.range.bottom.value < this.props.valueScale/2),
      range : {
        width: this.getRangeWidth(),
        leftOffset : this.getRangeLeftOffset(),
        value : makeDataLabel(
                this.props.dataset.range.bottom.value,
                this.props.indicator.datatype,
                this.props.indicator.unit
              ),
        label : makeGroupLabel(
                this.props.flux,
                this.props.indicator.breakdowns.split(','),
                this.props.dataset.range.bottom
              )

      }
    }]
  },
  getRangeWidth :function(){
    var range = this.props.dataset.range
    var maxValue = this.props.valueScale

    var diff = (range.order === 'DESC')
      ? range.bottom.value - range.top.value
      : range.top.value - range.bottom.value

    return Math.round((diff / maxValue) * 100, 2)

  },
  getRangeLeftOffset :function(){
    var range = this.props.dataset.range
    var maxValue = this.props.valueScale
    // DESC: less is better
    var left = (range.order === 'DESC')
      ? range.top.value
      : range.bottom.value

    return Math.round((left / maxValue) * 100, 2)

  },



// render by rank  ////////////////////////////////////////////////////////////////////



  renderByRank : function(refValue){

    var maxValue = this.props.valueScale

    var breakdowns = this.props.breakdowns
    var groups = this.props.groups



    // remove average values and sort
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })
            })
            .sortByOrder(['rank'],this.props.sortAsc).value()

    // render each datum individually
    return (
      <tbody className='table-body'>
      {
        _.map(data, function (datum, index, data) {

          // check for row highlight
          var highlight = this.checkHighlight(datum)
          var className = highlight ? 'row-highlight' : ''

          // check for real gaps

          var gap = data[index-1] ? datum.rank - data[index-1].rank : 1;

          if (index === 0
            || (gap < 2)
            || (data[index-gap] && data[index-gap].rank === data[index-1].rank)
          ) {
            // no gap
            return (
              <TableRow
                rowData = {this.prepareRowDataRank(
                  datum,
                  this.props.valueScale,
                  refValue,
                  this.props.indicator
                )}
                className = { className }
              />
            )
          } else {

            return (
              [
                <TableRow
                  rowData = {this.prepareRowSpacer(refValue,maxValue )}
                  className = { 'spacer spacer-gap' }
                />,
                <TableRow
                  rowData = {this.prepareRowDataRank(
                    datum,
                    this.props.valueScale,
                    refValue,
                    this.props.indicator
                  )}
                  className = { className }
                />
              ]
            )
          }

        }.bind(this))
      }
      { this.renderRange() }

     </tbody>
    )
  },
  checkHighlight : function(datum){
    var highlight  = false

    _.each(this.props.breakdowns,function(bd, index){

      group = _.find(this.props.groups[index],{short:datum[bd.id]})

      if (typeof group !== 'undefined' && group.highlight === 'y') {
        highlight = true
        return false
      }

    }.bind(this))

    return highlight

  },
  prepareRowDataRank : function (datum, maxValue, refValue, indicator) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1
    // one cell for each active dimension
    return _(this.props.breakdowns).map(function(bd){
        // get group cells
        return this.prepareLabelCell(
          makeGroupLabel(this.props.flux,[bd.id],datum)
        )
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarCell(datum.value, maxValue, refValue))
  },


// render by value ////////////////////////////////////////////////////////////////////


  renderByValue : function(refValue){
    var breakdowns = this.props.breakdowns
    // remove average values and sort
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })
            })
            .sortByOrder(['value'],this.props.sortDesc).value()

    // render each datum individually
    return (
      <tbody className='table-body'>
      {
        _.map(data, function (datum) {

            // check for row highlight
          var highlight = this.checkHighlight(datum)
          var className = highlight ? 'row-highlight' : ''

          return (
            <TableRow
              rowData = {this.prepareRowData(
                datum,
                this.props.valueScale,
                refValue,
                this.props.indicator
              )}
              className = { className }
            />
          )
        }.bind(this))
      }
      { this.renderRange() }

     </tbody>
    )
  },
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  prepareRowData : function (datum, maxValue, refValue, indicator) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1
    // one cell for each active dimension
    return _(this.props.breakdowns).map(function(bd){
        // get group cells
        return this.prepareLabelCell(
            (bd.id === 'cat')
                ? indicator.categories.split(',')[datum.cat]
                : makeGroupLabel(this.props.flux,[bd.id],datum)
          )
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarCell(datum.value, maxValue, refValue))
  },
  prepareLabelCell : function(label) {
   // only put label when different from previous group
    return {
      type : 'text',
      label : label,
      className : 'group-label'
    }

  },

  prepareBarCell: function (value, maxValue, refValue) {
    var type = 'horizontal-bar'
    if (this.props.indicator.datatype === 'categorical'
            || this.props.indicator.datatype === 'part-to-whole'){
      type = 'horizontal-bar-histogram'
    }

    return {
      type: type,
      colSpan : 2,
      length: this.getBarLength(value,maxValue),
      refLength: this.getBarLength(refValue,maxValue),
      label: makeDataLabel(value,this.props.indicator.datatype,this.props.indicator.unit),
      color: getDataColor(value,refValue,this.props.sortDesc)
    }
  },
  prepareBarSpacerCell: function (refValue,maxValue) {
    return {
      type: 'horizontal-bar-spacer',
      colSpan : 2,
      refLength: refValue === 0 || refValue === ''
      ? 0
      : this.getBarLength(refValue,maxValue)
    }
  },
  getBarLength: function(value,maxValue){
    value = typeof value === 'number' ? value : 0
    return Math.round((value / maxValue) * 100, 2)
  }

})
