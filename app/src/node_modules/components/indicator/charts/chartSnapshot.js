//main
var React           = require('react')


//components
var TableHeader     = require('./chartSnapshotHeader')
var TableGroup      = require('./chartSnapshotGroup')
var TableRow        = require('./chartSnapshotRow')

var makeGroupLabel  = require('utils/makeGroupLabel')
var makeDataLabel   = require('utils/makeDataLabel')
var getDataColour   = require('utils/getDataColour')
var cartesianProduct   = require('utils/cartesianProduct')



//helpers
var _               = require('lodash')

//logging
var log             = require('debug')('components:indicator:snapshot')


module.exports = React.createClass({

	propTypes : {
		flux        : React.PropTypes.object,    
		indicator   : React.PropTypes.object, // tehc urrent indicator
		breakdowns  : React.PropTypes.array, // breakdowns
		groups      : React.PropTypes.array, // groups for each breakdown
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')
    range       : React.PropTypes.object, // the top/bottom value for current dataset
	  sortBy      : React.PropTypes.string, // one of ["group","value"]    
    sortDesc    : React.PropTypes.bool // the indicator sort order [indicator.order === 'DESC']
  },

	getInitialState: function () {
		return {
			sortOptions: ['group','value']
		}
	},

  render: function () {
		log('props', this.props)
    
    if (this.props.indicator.datatype !== 'categorical') {
    
      return (

        <div className='snapshot'>
          <table className='table'>
            <TableHeader 
              breakdowns      = {this.props.breakdowns} 
              sortOptions     = {this.getInitialState().sortOptions } 
              sortBy          = {this.props.sortBy} 
              referenceDatum  = {this.referenceDatum()} 
            />
            { (this.props.sortBy !== 'groups') ? this.renderGroups() : this.renderValues() }					
          </table>
        </div>
      )
    } else {
      return (
        <p> work in progress </p>
      )
    }
  },
  
  referenceDatum : function(){    
    
    
    if (this.props.indicator.datatype === 'disfactor') {
      return {value:1}
    } else {
    
      var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
      // filter data by "all" for all breakdowns
      // TODO check for datasets that do not have "All people" average
      return _.findWhere(
        this.props.data,
        _.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all'))
      ) 
    }
  },
          
  // render by group ////////////////////////////////////////////////////////////////////
  
 
        
  renderGroups : function(){
    
    
    // remove average values
    var breakdowns = this.props.breakdowns 
    
    this.previousGroups = {}    
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })              
            }).value()
    var groupProduct = cartesianProduct(this.props.groups)
    var range = this.props.range        
    return (
      <tbody className='table-body'>     
        {
          _.map(groupProduct,function(group){
            //get the datum
            var filter = {}
            _.each(group,function(row){
              filter[row.breakdown] = row.short
            })              
            var datum = _(data).filter(filter).value()
            
            // figure out group configuration
            var currentGroups = _(group).map(function(attr){
                      return [attr.breakdown,attr.short]
                    }).zipObject().value()                        
            
            var previousGroups = this.previousGroups
            var className = this.isNewGroup(previousGroups,currentGroups) ? 'newGroup' : ''
            
            return (
                <TableRow 
                  rowData = {this.formatRowDataGrouped(
                    typeof datum[0] !== 'undefined' ? datum[0] : filter,
                    (range.top.value > range.bottom.value) ? range.top.value : range.bottom.value,
                    this.referenceDatum(),
                    currentGroups
                    )}
                  className = { className }
                />
              ) 
          },this)
        }         
      </tbody>
    )
  },
  isNewGroup : function(previousGroups,currentGroups){

    // new group of groups if last 2 group attributes are different
    if (_.isEmpty(previousGroups))  {
      return false
    } else {
      return _(this.props.breakdowns).every(function(val,index,self){
        return index < (self.length-2) || previousGroups[val.id] !== currentGroups[val.id]
      })
    } 
  },

  // render by value ////////////////////////////////////////////////////////////////////
  
  renderValues : function(){
    var breakdowns = this.props.breakdowns 
    // remove average values and sort
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })              
            })
            .sortByOrder(['value'],this.props.sortDesc).value()
    var range = this.props.range
    // render each datum individually
    return (
      <tbody className='table-body'>
      {
        _.map(data, function (datum) {
          return (
            <TableRow rowData = {this.formatRowData(
              datum,
              (range.top.value > range.bottom.value) ? range.top.value : range.bottom.value,
              this.referenceDatum()
            )} />
          )
        }.bind(this))
      }
     </tbody> 
    )
  },
  
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  formatRowDataGrouped : function (datum, maxValue, refDatum, currentGroups) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1
    refValue = typeof refValue !== 'undefined' ? refValue : 0.5
   
    // one cell for each active dimension
    var rowData = _(this.props.breakdowns).map(function(bd){
        // get group cells
        return this.formatGroupCell (bd.id,datum,this.previousGroups[bd.id])  
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.formatBarCell(datum.value, maxValue, refDatum))           

    
    //remember groups    
    this.previousGroups = currentGroups
      
    return rowData
  },
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  formatRowData : function (datum, maxValue, refValue) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1
    refValue = typeof refValue !== 'undefined' ? refValue : 0.5
    // one cell for each active dimension
    return _(this.props.breakdowns).map(function(bd){
        // get group cells
        return this.formatGroupCell (bd.id,datum)  
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.formatBarCell(datum.value, maxValue, refValue))           
  },
  formatGroupCell : function(breakdownId,datum,prevGroup) {
    prevGroup = typeof prevGroup !== 'undefined' ? prevGroup : ''
    
    // only put label when different from previous group
    if (prevGroup === '' || prevGroup !== datum[breakdownId]) {    
      return {
        type : 'text',
        label : makeGroupLabel(this.props.flux,[breakdownId],datum),
        className : 'group-label'
      }
    } else {
      return {
        type : 'text',
        label : '',
        className : 'group-label group-label-repeat'
      }
    }
  },

	formatBarCell: function (value, maxValue, refDatum) {
		return {
			type: 'horizontal-bar',
			length: this.getBarLength(value,maxValue),
			label: makeDataLabel(value,this.props.indicator.datatype,this.props.indicator.unit),
			color: getDataColour(this.props.sortDesc,value,refDatum)  
		}
	},
  getBarLength: function(value,maxValue){
    value = typeof value === 'number' ? value : 0    
    return Math.round((value/maxValue)*100, 2)    
  }
          
})
