//main
var React           = require('react')


//components
var TableHeader     = require('./chartSnapshotHeader')
var TableGroup      = require('./chartSnapshotGroup')
var TableRow        = require('./chartSnapshotRow')

var makeGroupLabel  = require('utils/makeGroupLabel')
var makeDataLabel   = require('utils/makeDataLabel')
var getDataColour   = require('utils/getDataColour')
var cartesianProduct   = require('utils/cartesianProduct')



//helpers
var _               = require('lodash')

//logging
var log             = require('debug')('components:indicator:snapshot')


module.exports = React.createClass({

  propTypes : {
    flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // tehc urrent indicator
    dataset    : React.PropTypes.object, // datasets/timesteps
    breakdowns  : React.PropTypes.array, // breakdowns
    groups      : React.PropTypes.array, // groups for each breakdown
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')
    sortBy      : React.PropTypes.string, // one of ["group","value"]
    axisScale   : React.PropTypes.number, // the max value
    sortDesc    : React.PropTypes.bool // the indicator sort order [indicator.order === 'DESC']
  },

  getInitialState: function () {
    return {
      sortOptions: ['group','value']
    }
  },

  render: function () {
    log('props', this.props)

      var refDatum = this.referenceDatum()
      return (

        <div className='snapshot'>
          <table className='table chart-table'>
            <TableHeader
              flux            = {this.props.flux}
              breakdowns      = {this.props.breakdowns}
              sortOptions     = {this.state.sortOptions }
              sortBy          = {this.props.sortBy}
              refDatumLabel    = {makeDataLabel(refDatum.value, this.props.indicator.datatype, this.props.indicator.unit)}
              refLength       = {this.getBarLength(refDatum.value, this.props.axisScale)}
              refLabel        = {this.props.indicator.referencelabel}
              zeroLabel       = {makeDataLabel(0, this.props.indicator.datatype, this.props.indicator.unit)}
            />
            { (this.props.sortBy === 'group') ? this.renderByGroup(refDatum.value) : this.renderByValue(refDatum.value) }
          </table>
        </div>
      )
  },

  referenceDatum : function(){
    if (this.props.indicator.datatype === 'disfactor') {
      return {value:1}
    } else if (this.props.indicator.datatype === 'categorical') {
      // temporary
      return {value:undefined}
    } else {

      var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
      // filter data by "all" for all breakdowns
      // TODO check for datasets that do not have "All people" average
      var ref = _.findWhere(
        this.props.data,
        _.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all'))
      )
      return (typeof ref !== 'undefined') ? ref : {value:undefined}
    }
  },

  // render by group ////////////////////////////////////////////////////////////////////



  renderByGroup : function(refValue){
    var maxValue = this.props.axisScale

    // remove average values
    var breakdowns = this.props.breakdowns
    var indicator = this.props.indicator

    this.previousGroups = {}
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })
            }).value()
    var groupProduct = cartesianProduct(this.props.groups)

    var range = this.props.dataset.range
    return (
      <tbody className='table-body'>
        {
          _.map(groupProduct,function(group){
            //get the datum
            var filter = {}
            _.each(group,function(row){
              filter[row.breakdown] = row.short
            })

            var datum = _(data).filter(filter).value()


            // figure out group configuration
            var currentGroups = _(group).map(function(attr){
                      return [attr.breakdown,attr.short]
                    }).zipObject().value()

            var previousGroups = this.previousGroups

            if (this.isNewGroup(previousGroups,currentGroups)) {
                return (
                [
                  <TableRow
                    rowData = {this.prepareRowSpacer(refValue,maxValue )}
                    className = { 'spacer' }
                  />,
                  <TableRow
                    rowData = {this.prepareRowDataGrouped(
                      typeof datum[0] !== 'undefined' ? datum[0] : filter,
                      maxValue,
                      refValue,
                      currentGroups,
                      indicator
                      )}
                    className = { 'data-row new-group' }
                  />
                ])
            } else {
              return (
                  <TableRow
                    rowData = {this.prepareRowDataGrouped(
                      typeof datum[0] !== 'undefined' ? datum[0] : filter,
                      maxValue,
                      refValue,
                      currentGroups,
                      indicator
                      )}
                    className = { 'data-row' }
                  />
                )
            }
          },this)
        }
      </tbody>
    )
  },
  isNewGroup : function(previousGroups,currentGroups){
    
    // new group of groups if last 2 group attributes are different
    if (_.isEmpty(previousGroups) || this.props.breakdowns.length === 1)  {
      return false
    } else {
      var isNewGroup = false
      _.each(this.props.breakdowns, function(val,index,self){        

        // if last item
        if (self.length-1 === index) {
          isNewGroup = isNewGroup || false
        } else {
          isNewGroup = isNewGroup || previousGroups[val.id] !== currentGroups[val.id]
        }

      })

      return isNewGroup
    } 

  },

  

  // for group sorted rows
  prepareRowDataGrouped : function (datum, maxValue, refValue, currentGroups, indicator) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1

    var repeatLabel = false
    // one cell for each active dimension
    var rowData = _(this.props.breakdowns).map(function(bd){
        // get group cells
        //once different always different (for each row)
        repeatLabel =
                repeatLabel
             || typeof this.previousGroups[bd.id] === 'undefined'
             || this.previousGroups[bd.id] === ''
             || datum[bd.id] !== this.previousGroups[bd.id]

        return this.prepareLabelCell (
            (!repeatLabel)
              ? ''
              : (bd.id === 'cat')
                ? indicator.categories.split(',')[datum.cat]
                : makeGroupLabel(this.props.flux,[bd.id],datum)
          )

      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarCell(datum.value, maxValue, refValue))


    //remember groups
    this.previousGroups = currentGroups

    return rowData
  },
  prepareRowSpacer : function (refValue,maxValue) {

    // one cell for each active dimension
    var rowData = _(this.props.breakdowns).map(function(bd){
        return this.prepareLabelCell ('')
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarSpacerCell(refValue,maxValue))

    return rowData
  },
          
// render by value ////////////////////////////////////////////////////////////////////

  renderByValue : function(refValue){
    var breakdowns = this.props.breakdowns
    // remove average values and sort
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })
            })
            .sortByOrder(['value'],this.props.sortDesc).value()
    var range = this.props.dataset.range

    // render each datum individually
    return (
      <tbody className='table-body'>
      {
        _.map(data, function (datum) {
          return (
            <TableRow rowData = {this.prepareRowData(
              datum,
              this.props.axisScale,
              refValue,
              this.props.indicator
            )} />
          )
        }.bind(this))
      }
     </tbody>
    )
  },          
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  prepareRowData : function (datum, maxValue, refValue, indicator) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1
    // one cell for each active dimension
    return _(this.props.breakdowns).map(function(bd){
        // get group cells
        return this.prepareLabelCell (
            (bd.id === 'cat')
                ? indicator.categories.split(',')[datum.cat]
                : makeGroupLabel(this.props.flux,[bd.id],datum)
          )
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.prepareBarCell(datum.value, maxValue, refValue))
  },
  prepareLabelCell : function(label) {
   // only put label when different from previous group
    return {
      type : 'text',
      label : label,
      className : 'group-label'
    }

  },

  prepareBarCell: function (value, maxValue, refValue) {
    return {
      type: 'horizontal-bar',
      length: this.getBarLength(value,maxValue),
      refLength: this.getBarLength(refValue,maxValue),
      label: makeDataLabel(value,this.props.indicator.datatype,this.props.indicator.unit),
      color: getDataColour(this.props.sortDesc,value,refValue)
    }
  },
  prepareBarSpacerCell: function (refValue,maxValue) {
    return {
      type: 'horizontal-bar-spacer',
      refLength: this.getBarLength(refValue,maxValue)
    }
  },
  getBarLength: function(value,maxValue){
    value = typeof value === 'number' ? value : 0
    return Math.round((value/maxValue)*100, 2)
  }

})
