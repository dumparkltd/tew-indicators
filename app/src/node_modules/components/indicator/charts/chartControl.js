//main
var React       				= require('react')
var Fluxxor     				= require('fluxxor')
var StoreWatchMixin     = Fluxxor.StoreWatchMixin
var FluxMixin 					= Fluxxor.FluxMixin(React)

var Snapshot 						= require('./snapshot/chartSnapshot')
var Timeline 						= require('./timeline/chartTimeline')

//helpers
var _ 					= require('lodash')

//logging
var log       	= require('debug')('components:indicator:chartControl')


module.exports = React.createClass({

	propTypes : {
		flux        : React.PropTypes.object,
    indicator   : React.PropTypes.object, // current indicator
    datasets    : React.PropTypes.array, // datasets/timesteps
		breakdowns  : React.PropTypes.array, // dimensions ordered by dimension, exluding null dimensions
		groups      : React.PropTypes.array, // groups for each dimension
    data        : React.PropTypes.array, // filtered data by datasets,dimensions&groups (including all 'alls'
    valueScale  : React.PropTypes.number, // the max value
    sortBy      : React.PropTypes.string, // one of ["group","value"]
    sortOptions : React.PropTypes.array
	},

  mixins: [FluxMixin, StoreWatchMixin('charts') ],

  getStateFromFlux: function() {
   return {
     highlightGroups : this.props.flux.store('charts').getHighlightGroups(),
     highlightDatasets : this.props.flux.store('charts').getHighlightDatasets()
   };
 },
  render: function () {
		log('props', this.props)


    if (this.props.datasets.length === 1) {
      return (
        <Snapshot
          flux = {this.props.flux}
          indicator = {this.props.indicator}
          dataset = {this.props.datasets[0]}
          breakdowns = {this.props.breakdowns}
          groups = {this.props.groups}
          data = {this.props.data}
          valueScale = {this.props.valueScale} // for first dataset
          sortBy = {this.props.sortBy}
          sortOptions = {this.props.sortOptions}
          sortDesc = {this.props.indicator.order === 'DESC'}
        />
      )
    } else {
      var highlightGroups = this.state.highlightGroups
      var highlightDatasets = this.state.highlightDatasets
      if (highlightGroups.length === 0 && highlightDatasets.length === 0){
        highlightGroups = [_.fill(Array(this.props.indicator.breakdowns.split(',').length), 'all')]
        
         
        // use highlight group if "all people" highlight group not present, 
        // but only for one breakdown only        
        if (this.props.breakdowns.length === 1) {
          // check if all people data available 
          var datum = _.find(this.props.data,function(datum){
            return this.isGroupActive(this.getGroupProperties(datum),highlightGroups)
          }.bind(this))
          
          // use highlight group
          if (typeof datum === 'undefined') {
            
            
            highlightGroups = [_.map(this.props.indicator.breakdowns.split(','),function(bd){
              var highlightGroup = _.find(_.flatten(this.props.groups),function(group){
                return group.breakdown === bd 
                  && typeof group.highlight !== 'undefined'
                  && group.highlight === 'y' 
              })
              return typeof highlightGroup === 'undefined' 
                ? ''
                : highlightGroup.short
            }.bind(this))]
            
          }
        }
        
      }
      

      return (
        <Timeline
          flux = {this.props.flux}
          indicator = {this.props.indicator}
          datasets = {this.props.datasets}
          breakdowns = {this.props.breakdowns}
          highlightGroups = {highlightGroups}
          highlightDatasets = {highlightDatasets}
          data = {this.props.data}
          valueScale = {this.props.valueScale}
          sortDesc = {this.props.indicator.order === 'DESC'}
        />
      )
    }

  },
  getGroupProperties : function(datum){
    return _.map(this.props.indicator.breakdowns.split(','),function(bd){
      return datum[bd]
    })
  },
  isGroupActive : function(groupProperties,highlightGroups){
    return _.filter(highlightGroups, function(g){return _.isEqual(g,groupProperties)}).length > 0
  },


})
