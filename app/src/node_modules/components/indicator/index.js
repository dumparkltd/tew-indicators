//main
var React       				= require('react')
var Fluxxor     				= require('fluxxor')
var StoreWatchMixin     = Fluxxor.StoreWatchMixin
var FluxMixin 					= Fluxxor.FluxMixin(React)

//components
var Explore 						= require('./explore')
var TimeSelect 					= require('./time-select')
var Filters 						= require('./filters')
var Chart               = require('./chartControl')
var NavPrimary          = require('components/nav-primary')
var Grid                = require('react-bootstrap/lib/Grid')
var Row 								= require('react-bootstrap/lib/Row')
var Col           			= require('react-bootstrap/lib/Col')

//modules
var getDatasets					= require('./get-datasets')

//helpers
var _ 									= require('lodash')
var traverse 						= require('traverse')

//logging
var log       					= require('debug')('src:components:indicator')

function findMatches (property, values) {
	return function (d) {
		return _.contains(values, d[property])
	}
}

var style = {
	index: {
		marginLeft: 16
	}
}

module.exports = React.createClass({

	mixins: [ FluxMixin, StoreWatchMixin('issues', 'indicators', 'data') ],

	propTypes : {
		flux: React.PropTypes.object,
		params: React.PropTypes.object
	},

	getStateFromFlux: function () {
		var flux = this.props.flux
		if (!flux.store("indicators").isLoading() && !this.props.query.d1 && this.props.params.indicatorSlug) {
			var indicator = this.props.flux.stores.indicators.findOne({ slug: this.props.params.indicatorSlug })
			var breakdownIds = indicator.breakdowns.split(',')
			flux.actions.indicator.selectDimension('d1', breakdownIds[0])
		}

    return {
      indicatorsLoading : flux.store("indicators").isLoading(),
      issuesLoading: flux.store('issues').isLoading(),
			dataLoading : flux.store('data').isLoading()
    }
  },

  render: function () {
		log('props', this.props)
		var flux = this.props.flux
		var dataQuery = _.clone(this.props.query)
		var View
		var indicator
		var issue
		var data
		var sortedDatasets
		var currentData
		var dimensions
		var dimensionFilter
		var unsetDimensions
		var filteredByDimensions
		var filteredByDimensionsAndQuery
		var breakdownIds
		var breakdowns = []
		var dataGroupsByDimension = []
		var dimensions = []
		var commentary

		if (this.state.indicatorsLoading || this.state.dataLoading || this.state.issuesLoading) {
			return (
				<div>
					<h3>Loading...</h3>
				</div>
			)
		}
		else {
			//what is my indicator?
			this.indicator = indicator = flux.stores.indicators.findOne({ slug: this.props.params.indicatorSlug })
			issue = flux.stores.issues.findOne({ id: indicator.issue })
			log('indicator', indicator)
			log('issue', issue)

			//get all the data for the indicator
			data = flux.stores.data.query({ indicator: indicator.id })
			log('data', data)

			//what datasets have these data?
			sortedDatasets = getDatasets(data, flux)

			//dataset defaults
			dataSetFilter = {}
			if (this.props.query.dataset) {
				if (this.props.query.dataset !== 'all') {
					dataSetFilter.dataset = this.props.query.dataset
				}
			}
			else {
				dataSetFilter.dataset = sortedDatasets[0].id
			}
			//get data by dataset
			currentData = _(data).reject({ value: '' }).filter(dataSetFilter).value()

			breakdownIds = indicator.breakdowns.split(',')
			dimensions = this.getDimensions(this.props.query, breakdownIds)
			breakdowns = this.getBreakdowns(breakdownIds)

			//filter by dimensions
			unsetDimensions = _.difference(breakdownIds, dimensions)
			dimensionFilter = _.zipObject(unsetDimensions, _.fill(Array(unsetDimensions.length), 'all'))
			filteredByDimensions = _.filter(currentData, dimensionFilter)

			dataGroupsByDimension = this.getDataGroups(currentData, dimensions)

			//filter by query
			// remove fields that aren't breakdownIds from our query
			dataQuery = _.pick(dataQuery, function (val, key) {
				return _.contains(breakdownIds, key)
			})
			filteredByDimensionsAndQuery = _.filter(filteredByDimensions, dataQuery)

			log('dimensionFilter', dimensionFilter)
			log('dataGroupsByDimension', dataGroupsByDimension)
			log('breakdowns', breakdowns)
			log('currentData', currentData)
			log('filteredByDimensions', filteredByDimensions)
			log('filteredByDimensionsAndQuery', filteredByDimensionsAndQuery)
      // TODO ranges for each dataset
      var ranges = [{top:{value:1,label:"Top"},bottom:{value:0,label:"Bottom"}}]
			//set View as ChartControl here

			View = (
				<div>
					<Chart
						flux={flux}
						indicator={indicator}
            datasets={_(sortedDatasets).filter({id:dataSetFilter.dataset}).value()}
						breakdowns={_(breakdowns).reject({dimension:null}).value()}
            groups={_(dataGroupsByDimension).reject({short:'all'}).value()}
            data={filteredByDimensionsAndQuery}
            ranges={ ranges }
            sortBy= {'value'}
					/>
				</div>
			)


      commentary = this.state.indicatorsLoading ? '' : _.map(indicator.commentary.split('\n'), function (line) {
        return <p>{line}</p>
      })

      var loading = this.state.indicatorsLoading
      return (
        <div className='indicator' style={style.index}>
          <NavPrimary
            flux = {flux}
            label = { {top:'Select',bottom:'Issue'} }
            type = 'issue'
            items = {
              _.map(flux.stores.issues.data,function(item){
                return _.assign({},item,{
                  active : issue.slug === item.slug,
                  subtitle : (this.state.indicatorsLoading) ? '' : flux.stores.indicators.query({ issue: item.id }).length + ' Indicators'
                })
              }.bind(this))
            }
          />
          <Grid>
            <div className='issue-link'>
              <p>{['Issue ', <a href="#" onClick={loading ? null : this.handleIssueClick(issue.slug)}>{loading ? '' : issue.title }</a>]}</p>
            </div>
            <h2>{loading ? "Loading indicator" : indicator.title}</h2>
            <Col className='main' md={9} xs={6}>
              <Explore
                flux={this.props.flux}
                query={this.props.query}
                breakdowns={breakdowns} />
              <Row>
                {View}
              </Row>
              <Row>
                {commentary}
              </Row>
            </Col>
            <Col className='right' md={3} xs={4}>
              <TimeSelect
                flux={this.props.flux}
                query={this.props.query}
                indicator={indicator}
                dateOptions={this.getDateOptions(sortedDatasets)} />
              <Filters
                flux={this.props.flux}
                query={this.props.query}
                dataGroupMatrix={dataGroupsByDimension}
                breakdowns={breakdowns} />
            </Col>
          </Grid>
        </div>
      )
    } // if loading
  },

	componentWillUpate: function (nextProps, nextState) {
		log('willUpdate', nextProps)
		// set the first dimension as the first breakdownId if it isn't present
		if (!nextState.indicatorsLoading && !nextProps.query.d1 && nextProps.params.indicatorSlug && nextProps.flux) {
			var indicator = nextProps.flux.stores.indicators.findOne({ slug: nextProps.params.indicatorSlug })
			var breakdownIds = indicator.breakdowns.split(',')
			nextProps.flux.actions.indicator.selectDimension('d1', breakdownIds[0])
		}
	},

	getDataGroups: function (data, dimensions) {
		if (this.props.flux.stores.dataGroups.isLoading()) return []
		log('getDataGroups: data', data)
		log('getDataGroups: dimensions', dimensions)
		var dataGroupsByDimension = []
		//'age' is a special case generated from current data
		breakdownIds = _.without(dimensions, 'age')

		//grab dataGroup ids from data for each breakdownId
		//then go to dataGroup store
		var shortsMatrix = _.map(breakdownIds, function (breakdownId) {
			return this.getShorts(data, breakdownId)
		}, this)

		log('getDataGroups: shortsMatrix', shortsMatrix)

		_.each(dimensions, function (dimension) {
			var dgs
			if (dimension === 'age') {
				dgs = this.getAgeGroups(data)
			}
			else {
				var index = breakdownIds.indexOf(dimension)
				dgs = _.map(shortsMatrix[index], function (short) {
					return this.props.flux.stores.dataGroups.findOne({ breakdown: dimension, short: short })
				}, this)
			}
			log('getDataGroups: dimension', dimension, dgs)
			dataGroupsByDimension.push(dgs)
		}, this)

		return dataGroupsByDimension
	},

	getShorts: function (data, breakdownId) {
		return _.keys(_.reduce(data, function (memo, d) {
			if (!memo[d[breakdownId]] && d[breakdownId] !== 'all') {
				memo[d[breakdownId]] = true
			}
			return memo
		}, {}))
	},

	//age groups are a special case of datagroup that are generated from available data
	getAgeGroups: function (data) {
		return _(data)
			.map(function (d) {
				return _.trim(d.age) //remove whitespace
			})
			.uniq()
			.map(function (age) {
				return {
					breakdown: 'age',
					short: age,
					title: age
				}
			})
			.value()
	},

	getBreakdowns: function (breakdownIds) {
		if (this.props.flux.stores.dataBreakdowns.isLoading()) return []
		var breakdowns = this.props.flux.stores.dataBreakdowns.filter(findMatches('id', breakdownIds))
		var first = this.props.query.d1
		var second = this.props.query.d2
		var third = this.props.query.d3

		return _(breakdowns)
			.map(function (breakdown) {
				var dimension = breakdown.id === first ? 1 : breakdown.id === second ? 2 : breakdown.id === third ? 3 : null
				return _.assign(breakdown, { dimension: dimension })
			})
			.sortBy(function (breakdown) {
				return breakdown.dimension || Infinity
			})
			.value()
	},

	getDateOptions: function (sortedDatasets) {
		return _.map(sortedDatasets, function (dataset) {
			log('getDateOptions: dataset', dataset)
			return {
				value: String(dataset['observationdate']),
				label: String(dataset['observationdate']),
				dataset: dataset
			}
		})
	},

	getDimensions: function (query, breakdownIds) {
		var dimensions = []
		if (query.d1) dimensions.push(query.d1)
		if (query.d2) dimensions.push(query.d2)
		if (query.d3) dimensions.push(query.d3)
		return dimensions
	},

	handleIssueClick: function (issueSlug) {
    var flux = this.props.flux

    return function (e) {
      e.preventDefault()
      flux.actions.issue.select(issueSlug)
    }.bind(this)
  }
})
