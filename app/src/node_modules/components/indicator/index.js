//main
var React       				= require('react')
var Fluxxor     				= require('fluxxor')
var StoreWatchMixin     = Fluxxor.StoreWatchMixin
var FluxMixin 					= Fluxxor.FluxMixin(React)

//components
var Table 							= require('react-simple-table')
var Snapshot 						= require('./snapshot')
var Timeline 						= require('./timeline')

//modules
var getDatasets					= require('./get-datasets')

//helpers
// var keys 				= require('lodash.keys')
var capitalize 					= require('capitalize')
var extend 							= require('xtend')
var _ 									= require('lodash')
var numeral							= require('numeral')
var d3InterpolateRGB		= require('d3-interpolate-rgb').interpolateRgb
var isArray 						= require('isarray')

//logging
var log       					= require('debug')('src:components:indicator')

function findMatches (property, values) {
	return function (d) {
		return _.contains(values, d[property])
	}
}

function findByDataQuery (dataQuery, referenceGroup) {
	return function (d) {
		if (_.every(referenceGroup, function (val, key) { return d[key] === val })) { return true } //always return the { key: 'all', key: 'all'}
		return _.every(dataQuery, function (val, key) {
			if (isArray(val)) {
				return _.contains(val, d[key])
			}
			else {
				return val === d[key]
			}
		})
	}
}

var style = {
	index: {
		marginLeft: 16
	}
}


module.exports = React.createClass({

	mixins: [ FluxMixin, StoreWatchMixin('indicators', 'data') ],

	propTypes : {
		flux: React.PropTypes.object,
		params: React.PropTypes.object
	},

	getInitialState: function () {
		return {
			cellOrder: { //NOTE hardcoded for now //these have an order assumption
				sex: 0,
				ethnicity: 1,
				age: 2,
				value: 3
			}
		}
	},

	getStateFromFlux: function () {
    var flux = this.props.flux
    return {
      indicatorsLoading : flux.store("indicators").isLoading(),
			dataLoading : flux.store('data').isLoading()
    }
  },

  render: function () {
		log('props', this.props)
		var flux = this.props.flux
		var dataQuery = _.clone(this.props.query)
		var indicator
		var issue
		var data
		var sortedDatasets
		var options
		var currentData
		var breakdownIds
		var breakdowns
		var dataGroups
		var View
		var orderBool
		var referenceGroup
		var queryFunction
		var commentary

		if (this.state.indicatorsLoading || this.state.dataLoading ) {
			View = (
				<div>
					<h3>Loading...</h3>
				</div>
			)
		}
		//set the View and load up with its data
		else if (this.props.query.dataset === 'all') {
			View = <Timeline/> //TODO
		}
		else if (!this.state.indicatorsLoading && !this.state.dataLoading) {
			//what is my indicator?
			this.indicator = indicator = flux.stores.indicators.findOne({ slug: this.props.params.indicatorSlug })
			orderBool = (indicator.order === 'DESC')
			issue = flux.stores.issues.findOne({ id: indicator.issue })
			log('indicator', indicator)
			log('issue', issue)

			//get all the data for the indicator
			data = flux.stores.data.query({ indicator: indicator.id })
			log('data', data)

			//what datasets have these data?
			sortedDatasets = getDatasets(data,flux)
			log('sortedDatasets', sortedDatasets)
			//configure dataQuery defaults
			if (dataQuery.dataset === 'all') {
				delete dataQuery.dataset
			}
			else if (!dataQuery.dataset) {
				dataQuery.dataset = sortedDatasets[0].id
			}
			log('dataQuery', dataQuery)

			//what are my breakdowns?
			breakdownIds = indicator.breakdowns.split(',')

			//remove query fields that are not breakdownIds
			dataQuery = _.pick(dataQuery, function (val, key) {
				return _.contains(breakdownIds, key)
			})

			referenceGroup = _.zipObject(breakdownIds, _.fill(Array(breakdownIds.length), 'all')) // search data for {key: 'all', key: 'all'}
			//create our special query function that will filter by the query string but also include the referenceGroup
			queryFunction = findByDataQuery(dataQuery, referenceGroup) //create a filtering query function from dataQuery
			currentData = this.getCurrentData(data, queryFunction, orderBool) // [data, maxValue]
			dataGroups = this.getDataGroups(breakdownIds)

			View = (
				<div>
					<Snapshot
						flux={flux}
						params={this.props.params}
						query={this.props.query}
						data={this.formatTableData(currentData[0], dataGroups, currentData[1])}
						breakdowns={this.getBreakdowns(breakdownIds)}
						indicator={indicator}
						dateOptions={this.getDateOptions(sortedDatasets)}/>
				</div>
			)
		}

		commentary = this.state.indicatorsLoading ? '' : _.map(indicator.commentary.split('\n'), function (line) {
			return <p>{line}</p>
		})

		var loading = this.state.indicatorsLoading
		return (
			<div className='indicator' style={style.index}>
				<div className='issue-link'>
					<p>{['Issue ', <a href="#" onClick={loading ? null : this.handleIssueClick(issue.slug)}>{loading ? '' : issue.title }</a>]}</p>
				</div>
				<h2>{loading ? "Loading indicator" : indicator.title}</h2>
				<h3>[Placeholder]: Snapshot, Timeline</h3>
				<div>
					{View}
				</div>
				<div>
					{commentary}
				</div>
			</div>
    )
  },

	getDataGroups: function (breakdownIds) {
		return this.props.flux.stores.dataGroups.filter(findMatches('breakdown', breakdownIds))
	},

	getBreakdowns: function (breakdownIds) {
		var breakdowns = this.props.flux.stores.dataBreakdowns.filter(findMatches('id', breakdownIds))
		var first = this.props.query.d1
		var second = this.props.query.d2
		var third = this.props.query.d3

		return _.map(breakdowns, function (breakdown) {
			var dimension = breakdown.id === first ? 1 : breakdown.id === second ? 2 : breakdown.id === third ? 3 : null
			return _.assign(breakdown, { dimension: dimension })
		})
	},

	getCurrentData: function (data, queryFunction, orderBool) {
		var maxValue = 0
		var currentData =	_(data)
				.reject({ value: '' })
				.filter(queryFunction)
				.each(function (d) {
					if (d.value > maxValue) maxValue = d.value
					return d
				})
				.sortByOrder('value', orderBool)
				.value()

		return [currentData, maxValue]
	},


	//data: Collection: -> [Row:[{Cell}, {Cell}...],Row:[{Cell}, {Cell}...]...]
	formatTableData: function (data, dataGroups, maxValue) {
		log('data', data)
		return _.map(data, function (d) {
			// log('d', d, this.state.cellOrder)
			var rowData = []
			_.each(d, function (val, key) {
				// log('val, key', val, key)
				if (typeof this.state.cellOrder[key] === 'number') { //check for breakdown existance (0 === 'falsy')
					if (key !== 'value') {
						var cellData = {} // { label: 'string', value: 'Number', type: 'string', onclick: 'function'}
						var dataGroup = _.find(dataGroups, { breakdown: key, short: val })
						// log('val, key', val, key, dataGroup)
						cellData.label = dataGroup ? dataGroup.title : val
						rowData[this.state.cellOrder[key]]  = cellData
					}
					else {
						rowData[this.state.cellOrder[key]]  = this.formatBarCell(val, maxValue)
					}

				}
			}.bind(this))
			return rowData
		}.bind(this))
	},

	formatBarCell: function (val, maxValue, indicator) {
		var label = (this.indicator.unit === '%') ? numeral(val).format('0.0%') : label
		var color = this.color()(val/maxValue)
		return {
			type: 'horizontal-bar',
			value: Math.round((val/maxValue)*100, 2),
			label: label,
			color: color
		}
	},

	color: function () {
		return d3InterpolateRGB('blue', 'red')
	},

	getDateOptions: function (sortedDatasets) {
		return _.map(sortedDatasets, function (dataset) {
			log('getDateOptions: dataset', dataset)
			return {
				value: String(dataset['observationdate']),
				label: 'Year: '+ dataset['observationdate']
			}
		})
	},

	handleIssueClick: function (issueSlug) {
    var flux = this.props.flux

    return function (e) {
      e.preventDefault()
      flux.actions.issue.select(issueSlug)
    }.bind(this)
  }




})
