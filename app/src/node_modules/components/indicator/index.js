//main
var React       				= require('react')
var Fluxxor     				= require('fluxxor')
var StoreWatchMixin     = Fluxxor.StoreWatchMixin
var FluxMixin 					= Fluxxor.FluxMixin(React)

//components
var FilterBreakdowns		= require('./filters/filter-breakdowns')
var FilterDataset			  = require('./filters/filter-dataset')
var FilterGroups				= require('./filters/filter-groups')
var Chart               = require('./charts/chartControl')
var Sources 						= require('./sources')
var NavPrimary          = require('components/nav-primary')
var Grid                = require('react-bootstrap/lib/Grid')
var Row 								= require('react-bootstrap/lib/Row')
var Col           			= require('react-bootstrap/lib/Col')

//modules
var getDatasets					= require('./get-datasets')
var getRange            = require('utils/getRange')

//helpers
var _ 									= require('lodash')
var traverse 						= require('traverse')
var marked 							= require('marked')

//logging
var log       					= require('debug')('src:components:indicator')

function findMatches (property, values) {
	return function (d) {
		return _.contains(values, d[property])
	}
}

var style = {
	index: {
		marginLeft: 16
	}
}

module.exports = React.createClass({

	mixins: [ FluxMixin, StoreWatchMixin('issues', 'indicators', 'data') ],

	propTypes : {
		flux: React.PropTypes.object,
		params: React.PropTypes.object
	},

	getStateFromFlux: function () {
		var flux = this.props.flux

    return {
      indicatorsLoading : flux.store("indicators").isLoading(),
      issuesLoading: flux.store('issues').isLoading(),
			dataLoading : flux.store('data').isLoading()
    }
  },

  render: function () {
		log('props', this.props)
		var flux = this.props.flux
		var dataQuery = _.clone(this.props.query)
		var View
		var indicator
		var issue
		var data
		var sortedDatasets
		var activeDatasets
		var currentData
		var breakdownFilter
		var sortBy

		var breakdownIds = []
    var breakdownDefault
		var breakdownsRequired = []
    var activeBreakdownIds = []
    var activeBreakdowns = []
    var inactiveBreakdownIds = []
		var breakdownOptions = []
		var dataGroupsByActiveBreakdowns = []

    var categories = []

		var commentary
    var ranges = []

		if (this.state.indicatorsLoading || this.state.dataLoading || this.state.issuesLoading) {
			return (
				<div>
					<h3>Loading...</h3>
				</div>
			)
		}
		else {
			// 1. indicator ///////////////////////////////////////////////////////////
			this.indicator = indicator = flux.stores.indicators.findOne({ slug: this.props.params.indicatorSlug })

      // 2. issue ///////////////////////////////////////////////////////////
			issue = flux.stores.issues.findOne({ id: indicator.issue })

			// 3. data for indicator
			data = _.clone(flux.stores.data.query({ indicator: indicator.id }))
      log('data',data)

			// 4. all and active datasets
			sortedDatasets = getDatasets(data, flux)
      log('sortedDatasets',sortedDatasets)
      dataSetFilter = {}
			if (this.props.query.dataset) {
				if (this.props.query.dataset === 'all') {
          activeDatasets = sortedDatasets
				} else {
          activeDatasets = _.filter(sortedDatasets,{id:this.props.query.dataset})
          dataSetFilter.dataset = this.props.query.dataset
        }
			}
			else {
				activeDatasets = [sortedDatasets[0]]
        dataSetFilter.dataset = sortedDatasets[0].id
			}
      log('activeDatasets',activeDatasets)

      // breakdowns
			breakdownIds = indicator.breakdowns.split(',')
      breakdownIds = breakdownIds[0] === '' ? [] : breakdownIds

      // required breakdowns
      breakdownsRequired = []
      if (indicator.required !== '') {
        breakdownsRequired.push(indicator.required)
      }
      // treat categories as another dimension
      if (indicator.datatype === 'categorical') {
        breakdownsRequired.push('cat')
        // check if cat only breakdown

      }
      if(indicator.multidimensional === 'n'
          && (breakdownIds.length === 0 || breakdownIds[0] === '')
          && indicator.datatype === 'categorical'){
        breakdownDefault = 'cat'
      } else {
      // default breakdown for first dimension
        breakdownDefault = breakdownIds[0]
      }

      // dimensions(ordered breakdowns, including default and required)
      activeBreakdownIds = this.getActiveBreakdowns(
              indicator,
              this.props.query,
              breakdownIds,
              breakdownDefault,
              breakdownsRequired)
      log('activeBreakdownIds',activeBreakdownIds)
      // prepare breakdown options by dimension for explore component
      breakdownOptions = this.getBreakdownOptions(indicator,activeBreakdownIds,breakdownIds)
      log('breakdownOptions',breakdownOptions)

      activeBreakdowns = []
      _.each(breakdownOptions,function(dim){
        // can only be one
        var active = _.filter(dim,{active:true})[0]
        if (typeof active !== 'undefined') {
          activeBreakdowns.push(active)
        }
      })
      log('activeBreakdowns',activeBreakdowns)

      // filter data by activeBreakdownIds (for inactve dimensions only keep 'all' rows)
			inactiveBreakdownIds = _.difference(breakdownIds, activeBreakdownIds)
      log('inactiveBreakdownIds',inactiveBreakdownIds)
			breakdownFilter = _.zipObject(inactiveBreakdownIds, _.fill(Array(inactiveBreakdownIds.length), 'all'))
      log('breakdownFilter',breakdownFilter)
			data = _.filter(data, breakdownFilter)
      log('data',data)
      // explode data if categorical
      if (indicator.datatype === 'categorical') {
        categories = indicator.categories.split(',')
        data = this.explodeCategories(categories,data)
      }
      log('data',data)

      // lets remove empty data points
      data = _.reject(data,{ value: '' })

      // get groups for every dimension
      dataGroupsByActiveBreakdowns = this.extractDataGroups(dataQuery, data, activeBreakdownIds, categories)

      log('dataGroupsByActiveBreakdowns',dataGroupsByActiveBreakdowns)

      // get ranges (top/bottom) for each acvtive dataset
      ranges = _(activeDatasets).map(function(dataset){
        return getRange(_(data).filter({dataset:dataset.id}).value(),indicator)
      }).value()

      log('ranges',ranges)

      sortBy = (indicator.datatype === 'categorical')
        ? 'groups'
        : (typeof dataQuery.sortBy !== 'undefined')
          ? dataQuery.sortBy
          : 'groups'

			// remove fields that aren't breakdownIds from our query
			dataQuery = _.pick(dataQuery, function (val, key) {
				return _.contains(activeBreakdownIds, key)
			})
			log('dataQuery', dataQuery)

      // filter data by dataset, and query
      data = this.filterByQuery(
            _(data)
              .filter(dataSetFilter)
              .value(),
            dataQuery)

     log('data - filtered', data)

			View = (
				<div>
					<Chart
						flux={flux}
						indicator={indicator}
            datasets={activeDatasets}
						breakdowns={activeBreakdowns}
            groups={this.filterDataGroupsByQuery(dataGroupsByActiveBreakdowns, dataQuery)}
            data={data}
            ranges={ ranges }
            sortBy= { sortBy }
					/>
				</div>
			)

      var loading = this.state.indicatorsLoading

      return (
        <div className='indicator' style={style.index}>
          <NavPrimary
            flux = {flux}
            label = { {top:'Select',bottom:'Issue'} }
            type = 'issue'
            items = {
              _.map(flux.stores.issues.data,function(item){
                return _.assign({},item,{
                  active : issue.slug === item.slug,
                  subtitle : (this.state.indicatorsLoading) ? '' : flux.stores.indicators.query({ issue: item.id }).length + ' Indicators'
                })
              }.bind(this))
            }
          />
          <Grid>
            <div className='issue-link'>
              <p>{['Issue ', <a href="#" onClick={loading ? null : this.handleIssueClick(issue.slug)}>{loading ? '' : issue.title }</a>]}</p>
            </div>
            <h2>{loading ? "Loading indicator" : indicator.title}</h2>
            <Col className='main' md={9} xs={6}>
							{
								(breakdownOptions.length <= 1 && breakdownOptions[0].length <= 1) ? null : this.renderFilterBreakdowns(breakdownOptions)
							}
              <Row>
                {View}
              </Row>
              <Row>
								<div
				          className="commentary"
				          dangerouslySetInnerHTML={{
				            __html: loading ? '' : marked(indicator.commentary, {sanitize: true})
				          }}
				        />
              </Row>
            </Col>
            <Col className='right' md={3} xs={4}>
              <FilterDataset
                flux={this.props.flux}
                indicator={indicator}
                dateOptions={this.getDateOptions(sortedDatasets)} />
              <FilterGroups
                flux={this.props.flux}
                dataGroupMatrix={dataGroupsByActiveBreakdowns}
                breakdowns={activeBreakdowns} />
							<Sources datasets={activeDatasets} />
            </Col>
          </Grid>
        </div>
      )
    }
  },

	renderFilterBreakdowns: function (breakdownOptions) {
		return (
			<FilterBreakdowns
				flux={this.props.flux}
				queryArg = 'dim'
				breakdownOptions={breakdownOptions} />
		)
	},

	extractDataGroups: function (query, data, activeBreakdownIds,categories) {
		if (this.props.flux.stores.dataGroups.isLoading()) return []

		var dataGroupsByActiveBreakdowns = []


		_.each(activeBreakdownIds, function (active) {
			var dgs
			if (active === 'age') {
				dgs = this.extractAgeGroups(query, data)
			}
			else if (active === 'cat') {
				dgs = this.extractCatGroups(query, data,categories)
			}
			else {
        dgs = this.extractBreakdownGroups(query, data,active)
			}
			dataGroupsByActiveBreakdowns.push(dgs)
		}, this)

		return dataGroupsByActiveBreakdowns
	},
  extractBreakdownGroups : function(query, data, breakdown){
    var groupIds = _.without(_.uniq(_.pluck(data,breakdown)),'all')

    return _.map(groupIds,function(groupId){
      var group = this.props.flux.stores.dataGroups.findOne({
        breakdown: breakdown,
        short: groupId
      })
      group.active = this.isGroupInQuery(query,breakdown,groupId)
      return group
    },this)

  },
  extractAgeGroups : function(query, data){
    var breakdown = 'age'
    var groupIds = _.without(_.uniq(_.pluck(data,breakdown)),'all')

    return _.sortBy(_.map(groupIds,function(groupId){
      var group = this.props.flux.stores.dataGroups.findOne({ breakdown: breakdown, short: groupId })

      if (typeof group === 'undefined'){
        group = {
					breakdown: breakdown,
					short: groupId,
					title: groupId,
				}
      }
      group.active = this.isGroupInQuery(query,breakdown,groupId)
      return group
    },this),'title')
  },

  extractCatGroups : function(query, data, categories){
    var breakdown = 'cat'
    return _.map(_.without(_.uniq(_.pluck(data,breakdown)),'all'),function(groupId){
      return {
					breakdown: breakdown,
					short: groupId.toString(),
					title: categories[groupId],
          active:this.isGroupInQuery(query,breakdown,groupId)
      }
    },this)
  },
  isGroupInQuery: function(query,breakdown,groupId){
      var queryField = query[breakdown]
      return typeof queryField !== 'undefined'
              && (  (  _.isArray(queryField)
                     && _.contains(queryField, groupId.toString()))
                  || queryField === groupId.toString()
              )
  },

	getBreakdownOptions: function (indicator, activeBreakdownIds, breakdownIds) {
		if (this.props.flux.stores.dataBreakdowns.isLoading()) return []
    // get breakdowns from store
    var breakdowns = this.props.flux.stores.dataBreakdowns.filter(findMatches('id', breakdownIds))
    var dim = []
    var actives = []
    var options = []
    // test for one-dimensional data
    if(indicator.multidimensional === 'n'){
      dim = []

      dim.push({
        active : true,
        optional : true,
        id : activeBreakdownIds[0],
        title : activeBreakdownIds[0] === 'cat'
          ? indicator.categorylabel
          : _.findWhere(breakdowns,{id:activeBreakdownIds[0]}).title
      })
      // if not active add to list
      _.each(breakdownIds,function(bdid){
        if(activeBreakdownIds.indexOf(bdid) === -1 ){
          dim.push({
            active : false,
            id:bdid,
            optional : bdid === 'cat' ? false : true,
            title : _.findWhere(breakdowns,{id:bdid}).title
          })
        }
      })

      options.push(dim)


    } else {
      // include 'cat' if present
      var allBreakdownIds = _.union(breakdownIds,activeBreakdownIds)
      // for each dimension (and)
      _.each(allBreakdownIds,function(bdid_and,index){
        //only allow one more dimension than currently active
        if(index <= _.without(activeBreakdownIds,'cat').length ) {
          dim = []
          //if active breakdown exists for dimension
          if (index < activeBreakdownIds.length) {
            actives.push(activeBreakdownIds[index])
            dim.push({
              active : true,
              optional : activeBreakdownIds[index] !== 'cat',
              id : activeBreakdownIds[index],
              title : activeBreakdownIds[index] === 'cat'
                ? indicator.categorylabel
                : _.findWhere(breakdowns,{id:activeBreakdownIds[index]}).title
            })
          }
          // for each option (or)
          // if not active in previous dimension add to list
          _.each(allBreakdownIds,function(bdid_or){
            if(actives.indexOf(bdid_or) === -1 ){
              dim.push({
                active : false,
                optional : bdid_or !== 'cat',
                id : bdid_or,
                title : bdid_or === 'cat'
                  ? indicator.categorylabel
                  : _.findWhere(breakdowns,{id:bdid_or}).title
              })
            }
          })
          options.push(dim)
        }
      })


    }
    return options


	},


	getActiveBreakdowns: function (indicator,query, breakdownIds, breakdownDefault, breakdownsRequired) {
		var activeBreakdowns = {}

    // stick default breakdown to front of the list if dim1 undefined in query
		if (!query.dim1) activeBreakdowns[1] = breakdownDefault
    //for each dimension in query
    _.each(query,function(val,key){
      var dim = key.split('dim')[1]
      if (!isNaN(parseFloat(dim)) && isFinite(dim)){
        activeBreakdowns[dim] = val
      }
    })

    // fill gaps with required breakdowns
    var keys = _.keys(activeBreakdowns).sort()
    for(var i = 1; i < keys.length; i++) {
      if(parseInt(keys[i]) - parseInt(keys[i-1]) !== 1) {
        for(var j = parseInt(keys[i-1])+1; j < parseInt(keys[i]); j++) {
         activeBreakdowns[j] = breakdownsRequired.shift()
        }
      }
    }

    // now add required breakdowns if not already included
    _.each(breakdownsRequired,function(bd){
      if (_.values(activeBreakdowns).indexOf(bd) === -1) {
        activeBreakdowns[_.keys(activeBreakdowns).length+1] = bd
      }
    })

    // only allow 1 dimension
    if(indicator.multidimensional === 'n') {
      return [activeBreakdowns[1]]
    } else {
      return _.values(activeBreakdowns)
    }


	},

  explodeCategories : function(categories,data){
    var exploded = []
    var values= []
    _.each(data,function(row){
      values = row.value.split(',')
      _.each(categories,function(cat,index){
        if (!isNaN(parseFloat(values[index])) && isFinite(values[index])){
          row.value = parseFloat(values[index])
        } else {
          row.value = ''
        }
        row.cat = index.toString()
        exploded.push(_.clone(row,true))
      })
    })
    return exploded

  },

	filterDataGroupsByQuery: function (dataGroupsByDimension, dataQuery) {
		if (_.keys(dataQuery).length === 0) return dataGroupsByDimension
		return _.map(dataGroupsByDimension, function (dataGroups) {
			return _.reduce(dataGroups, function (memo, group) {
				if (dataQuery[group.breakdown]) {
					if (_.isArray(dataQuery[group.breakdown]) && _.contains(dataQuery[group.breakdown], group.short)) {
						memo.push(group)
					}
					else if (dataQuery[group.breakdown] === group.short) {
						memo.push(group)
					}
				}
				else {
					memo.push(group)
				}
				return memo
			}, [])
		})
	},

	filterByQuery: function (data, query) {
		return _.filter(data, function (d) {
			return _.every(query, function (val, key) {
				if (d[key] === 'all') return true //include the all with each explicity filtered field
				if (_.isArray(val)) {
					 return _.contains(val, d[key])
				}
				else {
					return d[key] === val
				}
			})
		})
	},

	getDateOptions: function (sortedDatasets,activeDatasets) {
		return _.map(sortedDatasets, function (dataset) {
			log('getDateOptions: dataset', dataset)
			return {
				value: dataset.id,
				label: String(dataset['observationdate']),
        active : _.filter(activeDatasets,{id:dataset.id}).length > 0,
				dataset: dataset
			}
		})
	},

	handleIssueClick: function (issueSlug) {
    var flux = this.props.flux

    return function (e) {
      e.preventDefault()
      flux.actions.issue.select(issueSlug)
    }.bind(this)
  }
})
