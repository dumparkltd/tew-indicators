//main
var React       				= require('react')
var Fluxxor     				= require('fluxxor')
var StoreWatchMixin     = Fluxxor.StoreWatchMixin
var FluxMixin 					= Fluxxor.FluxMixin(React)

//components
var Explore 						= require('./explore')
var TimeSelect 					= require('./time-select')
var Filters 						= require('./filters')
var Chart               = require('./chartControl')
var NavPrimary          = require('components/nav-primary')
var Grid                = require('react-bootstrap/lib/Grid')
var Row 								= require('react-bootstrap/lib/Row')
var Col           			= require('react-bootstrap/lib/Col')

//modules
var getDatasets					= require('./get-datasets')

//helpers
var _ 									= require('lodash')

//logging
var log       					= require('debug')('src:components:indicator')

function findMatches (property, values) {
	return function (d) {
		return _.contains(values, d[property])
	}
}

var style = {
	index: {
		marginLeft: 16
	}
}

module.exports = React.createClass({

	mixins: [ FluxMixin, StoreWatchMixin('indicators', 'data') ],

	propTypes : {
		flux: React.PropTypes.object,
		params: React.PropTypes.object
	},

	getStateFromFlux: function () {
    var flux = this.props.flux
    return {
      indicatorsLoading : flux.store("indicators").isLoading(),
			dataLoading : flux.store('data').isLoading()
    }
  },

  render: function () {
		log('props', this.props)
		var flux = this.props.flux
		var dataQuery = _.clone(this.props.query)
		var View
		var indicator
		var issue
		var data
		var sortedDatasets
		var currentData
		var dimensions
		var dimensionFilter
		var unsetDimensions
		var filteredByDimensions
		var filteredByDimensionsAndQuery
		var breakdownIds
		var breakdowns = []
		var dataGroupsByDimension = []
		var dimensions = []
		var commentary

		if (this.state.indicatorsLoading || this.state.dataLoading ) {
			View = (
				<div>
					<h3>Loading...</h3>
				</div>
			)
		}
		else {
			//what is my indicator?
			this.indicator = indicator = flux.stores.indicators.findOne({ slug: this.props.params.indicatorSlug })
			issue = flux.stores.issues.findOne({ id: indicator.issue })
			log('indicator', indicator)
			log('issue', issue)

			//get all the data for the indicator
			data = flux.stores.data.query({ indicator: indicator.id })
			log('data', data)

			//what datasets have these data?
			sortedDatasets = getDatasets(data, flux)

			//dataset defaults
			dataSetFilter = {}
			if (this.props.query.dataset) {
				if (this.props.query.dataset !== 'all') {
					dataSetFilter.dataset = this.props.query.dataset
				}
			}
			else {
				dataSetFilter.dataset = sortedDatasets[0].id
			}
			//get data by dataset
			currentData = _(data).reject({ value: '' }).filter(dataSetFilter).value()

			breakdownIds = indicator.breakdowns.split(',')
			dimensions = this.getDimensions(this.props.query, breakdownIds)
			breakdowns = this.getBreakdowns(breakdownIds)

			//filter by dimensions
			unsetDimensions = _.difference(breakdownIds, dimensions)
			dimensionFilter = _.zipObject(unsetDimensions, _.fill(Array(unsetDimensions.length), 'all'))
			filteredByDimensions = _.filter(currentData, dimensionFilter)

			dataGroupsByDimension = this.getDataGroups(currentData, breakdownIds, dimensions)

			//filter by query
			// remove fields that aren't breakdownIds from our query
			dataQuery = _.pick(dataQuery, function (val, key) {
				return _.contains(breakdownIds, key)
			})
			filteredByDimensionsAndQuery = _.filter(filteredByDimensions, dataQuery)

			log('dimensionFilter', dimensionFilter)
			log('dataGroupsByDimension', dataGroupsByDimension)
			log('breakdowns', breakdowns)
			log('currentData', currentData)
			log('filteredByDimensions', filteredByDimensions)
			log('filteredByDimensionsAndQuery', filteredByDimensionsAndQuery)

			//set View as ChartControl here

			View = (
				<div>
					<Chart
						flux={flux}
						params={this.props.params}
						query={this.props.query}
						data={this.formatTableData(currentData[0], dataGroups, currentData[1])}
						breakdowns={breakdowns}
						indicator={indicator} />
				</div>
			)
		}

		commentary = this.state.indicatorsLoading ? '' : _.map(indicator.commentary.split('\n'), function (line) {
			return <p>{line}</p>
		})

		var loading = this.state.indicatorsLoading
		return (
			<div className='indicator' style={style.index}>
        <NavPrimary
          flux = {flux}
          label = { {top:'Select',bottom:'Issue'} }
          type = 'issue'
          items = {
            _.map(flux.stores.issues.data,function(item){
              return _.assign({},item,{
                active : issue.slug === item.slug,
                subtitle : (this.state.indicatorsLoading) ? '' : flux.stores.indicators.query({ issue: item.id }).length + ' Indicators'
              })
            }.bind(this))
          }
        />
        <Grid>
          <div className='issue-link'>
            <p>{['Issue ', <a href="#" onClick={loading ? null : this.handleIssueClick(issue.slug)}>{loading ? '' : issue.title }</a>]}</p>
          </div>
          <h2>{loading ? "Loading indicator" : indicator.title}</h2>
					<Col className='main' md={9} xs={6}>
						<Explore
							flux={this.props.flux}
							query={this.props.query}
							breakdowns={breakdowns} />
						<Row>
	            // {View}
	    			</Row>
						<Row>
	            {commentary}
	          </Row>
					</Col>
					<Col className='right' md={3} xs={4}>
						<TimeSelect
							flux={this.props.flux}
							query={this.props.query}
							indicator={indicator}
							dateOptions={this.getDateOptions(sortedDatasets)} />
						<Filters
							flux={this.props.flux}
							query={this.props.query}
							dataGroupMatrix={dataGroupsByDimension}
							breakdowns={breakdowns} />
					</Col>
        </Grid>
			</div>
    )
  },

	getDataGroups: function (data, breakdownIds, dimensions) {
		if (this.props.flux.stores.dataGroups.isLoading()) return []
		var dataGroupsByDimension = []
		//'age' is a special case generated from current data
		breakdownIds = _.pull(breakdownIds, 'age')

		var dataGroups = this.props.flux.stores.dataGroups
			.filter(findMatches('breakdown', breakdownIds))

		_.each(dimensions, function (dimension) {
			var dgs = dimension === 'age' ? this.getAgeGroups(data) : _.filter(dataGroups, { breakdown: dimension })
			log('dimension', dimension, dgs)
			dataGroupsByDimension.push(dgs)
		}, this)

		return dataGroupsByDimension
	},

	//age groups are a special case of datagroup that are generated from available data
	getAgeGroups: function (data) {
		return _(data)
			.map(function (d) {
				return _.trim(d.age) //remove whitespace
			})
			.uniq()
			.map(function (age) {
				return {
					breakdown: 'age',
					short: age,
					title: age
				}
			})
			.value()
	},

	getBreakdowns: function (breakdownIds) {
		if (this.props.flux.stores.dataBreakdowns.isLoading()) return []
		var breakdowns = this.props.flux.stores.dataBreakdowns.filter(findMatches('id', breakdownIds))
		var first = this.props.query.d1 || breakdownIds[0] //set default as
		var second = this.props.query.d2
		var third = this.props.query.d3

		return _(breakdowns)
			.map(function (breakdown) {
				var dimension = breakdown.id === first ? 1 : breakdown.id === second ? 2 : breakdown.id === third ? 3 : null
				return _.assign(breakdown, { dimension: dimension })
			})
			.sortBy(function (breakdown) {
				return breakdown.dimension || Infinity
			})
			.value()
	},

	getDateOptions: function (sortedDatasets) {
		return _.map(sortedDatasets, function (dataset) {
			log('getDateOptions: dataset', dataset)
			return {
				value: String(dataset['observationdate']),
				label: String(dataset['observationdate']),
				dataset: dataset
			}
		})
	},

	getDimensions: function (query, breakdownIds) {
		var dimensions = []
		if (query.d1) dimensions.push(query.d1)
		if (query.d2) dimensions.push(query.d2)
		if (query.d3) dimensions.push(query.d3)
		if (dimensions.length === 0) dimensions.push(breakdownIds[0]) //set default as first breakdownId
		return dimensions
	},

	handleIssueClick: function (issueSlug) {
    var flux = this.props.flux

    return function (e) {
      e.preventDefault()
      flux.actions.issue.select(issueSlug)
    }.bind(this)
  }
})
