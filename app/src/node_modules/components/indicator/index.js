//main
var React               = require('react')
var Fluxxor             = require('fluxxor')
var StoreWatchMixin     = Fluxxor.StoreWatchMixin
var FluxMixin           = Fluxxor.FluxMixin(React)

//components
var FilterBreakdowns    = require('./filters/filter-breakdowns')
var FilterDataset        = require('./filters/filter-dataset')
var FilterGroups        = require('./filters/filter-groups')
var Chart               = require('./charts/chartControl')
var Sources             = require('./sources')
var NavPrimary          = require('components/nav-primary')
var NavCarousel         = require('components/nav-carousel')
var Grid                = require('react-bootstrap/lib/Grid')
var Row                 = require('react-bootstrap/lib/Row')
var Col                 = require('react-bootstrap/lib/Col')

//modules
var getDatasets          = require('utils/get-datasets')
var getRange            = require('utils/getRange')

//helpers
var _                   = require('lodash')
var traverse             = require('traverse')
var marked               = require('marked')

//logging
var log                 = require('debug')('src:components:indicator')

function findMatches (property, values) {
  return function (d) {
    return _.contains(values, d[property])
  }
}


function cycleCarousel (value, list, direction) {
  var index = list.indexOf(value)
  if (direction === 'next') {
    if (index === list.length - 1) { return 0 }
    else { return index + 1 }
  }
  if (direction === 'previous') {
    if (index === 0) { return list.length - 1}
    else { return index - 1}
  }
}


var style = {
  index: {
    marginLeft: 16
  }
}

module.exports = React.createClass({

  mixins: [ FluxMixin, StoreWatchMixin('issues', 'indicators', 'data') ],

  propTypes : {
    flux: React.PropTypes.object,
    params: React.PropTypes.object
  },

  getStateFromFlux: function () {
    var flux = this.props.flux

    return {
      indicatorsLoading : flux.store("indicators").isLoading(),
      issuesLoading: flux.store('issues').isLoading(),
      dataLoading : flux.store('data').isLoading()
    }
  },

  render: function () {
    log('props', this.props)
    var flux = this.props.flux
    var dataQuery = _.clone(this.props.query)
    var View
    var indicator
    var issue
    var data
    var sortedDatasets
    var activeDatasets
    var currentData
    var breakdownFilter
    var sortBy
    var sortOptions = []
    var valueScale

    var breakdownIds = []
    var breakdownDefault
    var breakdownsRequired = []
    var activeBreakdownIds = []
    var activeBreakdowns = []
    var inactiveBreakdownIds = []
    var breakdownOptions = []
    var dataGroupsByActiveBreakdowns = []



    var categories = []

    var commentary
    var ranges = []

    if (this.state.indicatorsLoading || this.state.dataLoading || this.state.issuesLoading) {
      return (
        <div>
          <h3>Loading...</h3>
        </div>
      )
    }
    else {
      // 1. indicator ///////////////////////////////////////////////////////////
      this.indicator = indicator = flux.stores.indicators.findOne({ slug: this.props.params.indicatorSlug })
       // breakdowns
			breakdownIds = indicator.breakdowns.split(',')
      breakdownIds = breakdownIds[0] === '' ? [] : breakdownIds



      // 2. issue ///////////////////////////////////////////////////////////
      issue = flux.stores.issues.findOne({ id: indicator.issue })

      var indicators = flux.stores.indicators.query({ issue: issue.id })
      var indicatorSlugs = _.pluck(indicators, 'slug')
      var nextSlug = indicatorSlugs[cycleCarousel(indicator.slug, indicatorSlugs, 'next')]
      var previousSlug = indicatorSlugs[cycleCarousel(indicator.slug, indicatorSlugs, 'previous')]

      log('indicators', indicators)
      log('indicatorSlugs', indicatorSlugs)
      log('nextSlug', nextSlug)
      log('previousSlug', previousSlug)

      // 3. data for indicator
      data = _.clone(flux.stores.data.query({ indicator: indicator.id }))
      log('data',data)

      // explode data if categorical
      if (indicator.datatype === 'categorical') {
        categories = indicator.categories.split(',')
        data = this.explodeCategories(categories,data)
      }
      log('data',data)

      // lets remove empty data points
      data = _.reject(data,function(d){
        return (typeof d.value !== 'number')
      })

      // 4. all and active datasets
      sortedDatasets = getDatasets(data, flux)
      log('sortedDatasets',sortedDatasets)

      // get ranges (top/bottom) for each acvtive dataset
      sortedDatasets = _(sortedDatasets).map(function(dataset){
        dataset.range = getRange(_(data).filter({dataset:dataset.id}).value(),indicator)
        return dataset
      }).value()
      log('sortedDatasets - with ranges',sortedDatasets)



      dataSetFilter = {}
			if (this.props.query.dataset) {
				if (this.props.query.dataset === 'all') {
          // get values for top/bottom groups for all datasets
          activeDatasets = _.map(sortedDatasets,function(dataset){
            dataset.range.topSeries = _.filter(data,function(d){
              var dprops = _.map(breakdownIds,function(bd){
                return d[bd]
              })
              var datasetprops = _.map(breakdownIds,function(bd){
                return dataset.range.top[bd]
              })
              return _.isEqual(dprops,datasetprops)
            },this)
            dataset.range.bottomSeries = _.filter(data,function(d){
              var dprops = _.map(breakdownIds,function(bd){
                return d[bd]
              })
              var datasetprops = _.map(breakdownIds,function(bd){
                return dataset.range.bottom[bd]
              })
              return _.isEqual(dprops,datasetprops)
            },this)
            return dataset
          },this)


				} else {
          activeDatasets = _.filter(sortedDatasets,{id:this.props.query.dataset})
          dataSetFilter.dataset = this.props.query.dataset
        }
      }
      else {
        activeDatasets = [sortedDatasets[0]]
        dataSetFilter.dataset = sortedDatasets[0].id
      }
      log('activeDatasets',activeDatasets)







      // required breakdowns
      breakdownsRequired = []
      if (indicator.required !== '') {
        breakdownsRequired.push(indicator.required)
      }
      // treat categories as another dimension
      if (indicator.datatype === 'categorical') {
        breakdownsRequired.push('cat')
        // check if cat only breakdown

      }
      if(indicator.multidimensional === 'n'
          && (breakdownIds.length === 0 || breakdownIds[0] === '')
          && indicator.datatype === 'categorical'){
        breakdownDefault = 'cat'
      } else {
      // default breakdown for first dimension
        breakdownDefault = breakdownIds[0]
      }

      // dimensions(ordered breakdowns, including default and required)
      activeBreakdownIds = this.getActiveBreakdowns(
              indicator,
              this.props.query,
              breakdownIds,
              breakdownDefault,
              breakdownsRequired)
      log('activeBreakdownIds',activeBreakdownIds)
      // prepare breakdown options by dimension for explore component
      breakdownOptions = this.getBreakdownOptions(indicator,activeBreakdownIds,breakdownIds)
      log('breakdownOptions',breakdownOptions)

      activeBreakdowns = []
      _.each(breakdownOptions,function(dim){
        // can only be one
        var active = _.filter(dim,{active:true})[0]
        if (typeof active !== 'undefined') {
          activeBreakdowns.push(active)
        }
      })
      log('activeBreakdowns',activeBreakdowns)

      // filter data by activeBreakdownIds (for inactve dimensions only keep 'all' rows)
      inactiveBreakdownIds = _.difference(breakdownIds, activeBreakdownIds)
      log('inactiveBreakdownIds',inactiveBreakdownIds)
      breakdownFilter = _.zipObject(inactiveBreakdownIds, _.fill(Array(inactiveBreakdownIds.length), 'all'))
      log('breakdownFilter',breakdownFilter)
      data = _.filter(data, breakdownFilter)
      log('data',data)



      // get groups for every dimension
      dataGroupsByActiveBreakdowns = this.extractDataGroups(dataQuery, data, activeBreakdownIds, categories)

      log('dataGroupsByActiveBreakdowns',dataGroupsByActiveBreakdowns)



      if ((indicator.datatype === 'categorical' || indicator.datatype === 'part-to-whole')
          && activeBreakdowns.length > 1){
        sortBy = 'group'
        sortOptions = ['group']
      } else {
        sortOptions = ['group','value']
        if (typeof dataQuery.sortBy !== 'undefined') {
          sortBy = dataQuery.sortBy
        } else {
          sortBy = 'group'
        }
      }


      // remove fields that aren't breakdownIds from our query
      dataQuery = _.pick(dataQuery, function (val, key) {
        return _.contains(activeBreakdownIds, key)
      })
      log('dataQuery', dataQuery)

      // filter data by dataset, and query
      data = this.filterByQuery(
            _(data)
              .filter(dataSetFilter)
              .value(),
            dataQuery)

     log('data - filtered', data)

      // find the biggest value for all datasets
      // could also just get range for all data but this may be more efficient?
      valueScale = this.computeValueScale(indicator,sortedDatasets)

      View = (
        <div>
          <Chart
            flux={flux}
            indicator={indicator}
            datasets={activeDatasets}
            breakdowns={activeBreakdowns}
            groups={this.filterDataGroupsByQuery(dataGroupsByActiveBreakdowns, dataQuery)}
            data={data}
            valueScale={ valueScale }
            sortBy= { sortBy }
            sortOptions= { sortOptions }
          />
        </div>
      )

      var loading = this.state.indicatorsLoading

      return (
        <div className='indicator' style={style.index}>
          <NavPrimary
            flux = {flux}
            label = { {top:'Select',bottom:'Issue'} }
            type = 'issue'
            items = {
              _.map(flux.stores.issues.data,function(item){
                return _.assign({},item,{
                  active : issue.slug === item.slug,
                  subtitle : (this.state.indicatorsLoading) ? '' : flux.stores.indicators.query({ issue: item.id }).length + ' Indicators'
                })
              }.bind(this))
            }
          />
          <Grid>
            <Row className='indicator-top'>
              <Col className='indicator-header pull-left' md={4}>
                <h2 className='text-uppercase'>indicator</h2>
              </Col>
              <Col className='indicator-control pull-right' md={3}>
                <NavCarousel
                  issueSlug={issue.slug}
                  nextSlug={nextSlug}
                  previousSlug={previousSlug}
                  indicatorSlug={this.props.params.indicatorSlug}
                  flux={flux}/>
              </Col>
            </Row>

            <Row>
              <Col md={9}>
              <h1>{loading ? "Loading indicator" : indicator.title}</h1>
              </Col>
            </Row>

            <Row className='indicator-explain'>
              <Col className='indicator-title' md={9}>
                <h4 className="text-uppercase">How to read the data</h4>
                <div dangerouslySetInnerHTML={{
                  __html: marked(indicator.howtoreaddata, {sanitize: true})
                }} ></div>
              </Col>
              <Col className='indicator-definitions' md={3}>
                <h4 className="text-uppercase">Definitions</h4>
                <div dangerouslySetInnerHTML={{
                  __html: marked(indicator.aboutindicator, {sanitize: true})
                }} ></div>
              </Col>
            </Row>

            <Row className='indicator-main'>

              <Col className='main' md={9}>
                <Row className='indicator-dimension-filters'>
                  <Col md={12}>
                    {
                      (breakdownOptions.length <= 1 && breakdownOptions[0].length <= 1) ? null : this.renderFilterBreakdowns(breakdownOptions)
                    }
                  </Col>
                </Row>
                <Row className='indicator-chart'>
                  <Col md={12}>
                    {View}
                  </Col>
                </Row>
                <Row className='indicator-analysis'>
                  <Col md={12}>
                    <h2>ANALYSIS</h2>
                    <div
                      className="indicator-commentary"
                      dangerouslySetInnerHTML={{
                        __html: loading ? '' : marked(indicator.commentary, {sanitize: true})
                      }}
                    />
                  </Col>
                </Row>
              </Col>

              <Col className='indicator-secondary-filters' md={3}>
                <FilterDataset
                  flux={this.props.flux}
                  indicator={indicator}
                  dateOptions={this.getDateOptions(sortedDatasets)}
                  activeView={this.props.query.dataset === 'all' ? 'timeline' : 'snapshot'}
                  timelineOption={sortedDatasets.length > 1} />
                <FilterGroups
                  flux={this.props.flux}
                  dataGroupMatrix={dataGroupsByActiveBreakdowns}
                  breakdowns={activeBreakdowns}
                  groupHasActiveFilter={_.map(activeBreakdownIds, function (breakdownId) { return (this.props.query[breakdownId]) ? true : false }, this) } />
                <Sources datasets={activeDatasets} />
              </Col>

            </Row>

          </Grid>
        </div>
      )
    }
  },

  renderFilterBreakdowns: function (breakdownOptions) {
    return (
      <FilterBreakdowns
        flux={this.props.flux}
        queryArg = 'dim'
        breakdownOptions={breakdownOptions} />
    )
  },

  extractDataGroups: function (query, data, activeBreakdownIds,categories) {
    if (this.props.flux.stores.dataGroups.isLoading()) return []

    var dataGroupsByActiveBreakdowns = []


    _.each(activeBreakdownIds, function (active) {
      var dgs
      if (active === 'age') {
        dgs = this.extractAgeGroups(query, data)
      }
      else if (active === 'cat') {
        dgs = this.extractCatGroups(query, data,categories)
      }
      else {
        dgs = this.extractBreakdownGroups(query, data,active)
      }
      dataGroupsByActiveBreakdowns.push(dgs)
    }, this)

    return dataGroupsByActiveBreakdowns
  },
  extractBreakdownGroups : function(query, data, breakdown){
    var groupIds = _.without(_.uniq(_.pluck(data,breakdown)),'all')

    return _.map(groupIds,function(groupId){
      var group = this.props.flux.stores.dataGroups.findOne({
        breakdown: breakdown,
        short: groupId
      })
      group.active = this.isGroupInQuery(query,breakdown,groupId)
      return group
    },this)

  },
  extractAgeGroups : function(query, data){
    var breakdown = 'age'
    var groupIds = _.without(_.uniq(_.pluck(data,breakdown)),'all')

    return _.sortBy(_.map(groupIds,function(groupId){
      var group = this.props.flux.stores.dataGroups.findOne({ breakdown: breakdown, short: groupId })

      if (typeof group === 'undefined'){
        group = {
          breakdown: breakdown,
          short: groupId,
          title: groupId,
        }
      }
      group.active = this.isGroupInQuery(query,breakdown,groupId)
      return group
    },this),'title')
  },

  extractCatGroups : function(query, data, categories){
    var breakdown = 'cat'
    return _.map(_.without(_.uniq(_.pluck(data,breakdown)),'all'),function(groupId){
      return {
          breakdown: breakdown,
          short: groupId.toString(),
          title: categories[groupId],
          active:this.isGroupInQuery(query,breakdown,groupId)
      }
    },this)
  },
  isGroupInQuery: function(query,breakdown,groupId){
      var queryField = query[breakdown]
      return typeof queryField !== 'undefined'
              && (  (  _.isArray(queryField)
                     && _.contains(queryField, groupId.toString()))
                  || queryField === groupId.toString()
              )
  },

  getBreakdownOptions: function (indicator, activeBreakdownIds, breakdownIds) {
    if (this.props.flux.stores.dataBreakdowns.isLoading()) return []
    // get breakdowns from store
    var breakdowns = this.props.flux.stores.dataBreakdowns.filter(findMatches('id', breakdownIds))
    var dim = []
    var actives = []
    var options = []
    // test for one-dimensional data
    if(indicator.multidimensional === 'n'){
      dim = []

      dim.push({
        active : true,
        optional : true,
        id : activeBreakdownIds[0],
        title : activeBreakdownIds[0] === 'cat'
          ? indicator.categorylabel
          : _.findWhere(breakdowns,{id:activeBreakdownIds[0]}).title
      })
      // if not active add to list
      _.each(breakdownIds,function(bdid){
        if(activeBreakdownIds.indexOf(bdid) === -1 ){
          dim.push({
            active : false,
            id:bdid,
            optional : bdid === 'cat' ? false : true,
            title : _.findWhere(breakdowns,{id:bdid}).title
          })
        }
      })

      options.push(dim)


    } else {
      // include 'cat' if present
      var allBreakdownIds = _.union(breakdownIds,activeBreakdownIds)
      // for each dimension (and)
      _.each(allBreakdownIds,function(bdid_and,index){
        //only allow one more dimension than currently active
        if(index <= _.without(activeBreakdownIds,'cat').length ) {
          dim = []
          //if active breakdown exists for dimension
          if (index < activeBreakdownIds.length) {
            actives.push(activeBreakdownIds[index])
            dim.push({
              active : true,
              optional : activeBreakdownIds[index] !== 'cat',
              id : activeBreakdownIds[index],
              title : activeBreakdownIds[index] === 'cat'
                ? indicator.categorylabel
                : _.findWhere(breakdowns,{id:activeBreakdownIds[index]}).title
            })
          }
          // for each option (or)
          // if not active in previous dimension add to list
          _.each(allBreakdownIds,function(bdid_or){
            if(actives.indexOf(bdid_or) === -1 ){
              dim.push({
                active : false,
                optional : bdid_or !== 'cat',
                id : bdid_or,
                title : bdid_or === 'cat'
                  ? indicator.categorylabel
                  : _.findWhere(breakdowns,{id:bdid_or}).title
              })
            }
          })
          options.push(dim)
        }
      })


    }
    return options


  },


  getActiveBreakdowns: function (indicator, query, breakdownIds, breakdownDefault, breakdownsRequired) {
    var activeBreakdowns = {}

    // stick default breakdown to front of the list if dim1 undefined in query
    if (!query.dim1) activeBreakdowns[1] = breakdownDefault
    //for each dimension in query
    _.each(query,function(val,key){
      var dim = key.split('dim')[1]
      if (!isNaN(parseFloat(dim)) && isFinite(dim)){
        activeBreakdowns[dim] = val
      }
    })

    // fill gaps with required breakdowns
    var keys = _.keys(activeBreakdowns).sort()
    for(var i = 1; i < keys.length; i++) {
      if(parseInt(keys[i]) - parseInt(keys[i-1]) !== 1) {
        for(var j = parseInt(keys[i-1])+1; j < parseInt(keys[i]); j++) {
         activeBreakdowns[j] = breakdownsRequired.shift()
        }
      }
    }

    // now add required breakdowns if not already included
    _.each(breakdownsRequired,function(bd){
      if (_.values(activeBreakdowns).indexOf(bd) === -1) {
        activeBreakdowns[_.keys(activeBreakdowns).length+1] = bd
      }
    })

    // only allow 1 dimension
    if(indicator.multidimensional === 'n') {
      return [activeBreakdowns[1]]
    } else {
      // make sure sort order cannot be changed for part-to whole values
      if (indicator.datatype === 'part-to-whole'){
        var activeBreakdownsIds = _.values(activeBreakdowns)
        var sorted = []
        _.each(breakdownIds,function(bdid){
          if (activeBreakdownsIds.indexOf(bdid) > -1) {
            sorted.push(bdid)
          }
        })
        return sorted
      } else {
        return _.values(activeBreakdowns)
      }
    }


  },

  explodeCategories : function(categories,data){
    var exploded = []
    var values= []
    _.each(data,function(row){
      values = row.value.split(',')
      _.each(categories,function(cat,index){
        if (!isNaN(parseFloat(values[index])) && isFinite(values[index])){
          row.value = parseFloat(values[index])
        } else {
          row.value = ''
        }
        row.cat = index.toString()
        exploded.push(_.clone(row,true))
      })
    })
    return exploded

  },

  filterDataGroupsByQuery: function (dataGroupsByDimension, dataQuery) {
    if (_.keys(dataQuery).length === 0) return dataGroupsByDimension
    return _.map(dataGroupsByDimension, function (dataGroups) {
      return _.reduce(dataGroups, function (memo, group) {
        if (dataQuery[group.breakdown]) {
          if (_.isArray(dataQuery[group.breakdown]) && _.contains(dataQuery[group.breakdown], group.short)) {
            memo.push(group)
          }
          else if (dataQuery[group.breakdown] === group.short) {
            memo.push(group)
          }
        }
        else {
          memo.push(group)
        }
        return memo
      }, [])
    })
  },

  filterByQuery: function (data, query) {
    return _.filter(data, function (d) {
      return _.every(query, function (val, key) {
        if (d[key] === 'all') return true //include the all with each explicity filtered field
        if (_.isArray(val)) {
           return _.contains(val, d[key])
        }
        else {
          return d[key] === val
        }
      })
    })
  },

  getDateOptions: function (sortedDatasets,activeDatasets) {
    return _.map(sortedDatasets, function (dataset) {
      log('getDateOptions: dataset', dataset)
      return {
        value: dataset.id,
        label: dataset['observationdate'].getFullYear(),
        active : _.filter(activeDatasets,{id:dataset.id}).length > 0,
        dataset: dataset
      }
    })
  },


  computeValueScale : function(indicator,sortedDatasets){
    var valueScale = 1
    if (indicator.datatype !== 'part-to-whole') {
      valueScale = _.last(
        _(sortedDatasets)
          .pluck('range')
          .pluck(indicator.order === 'DESC' ? 'bottom' : 'top')
          .pluck('value')
          .uniq()
          .sortBy()
          .value()
        )
      if (valueScale < 1) {
        valueScale = Math.ceil(valueScale*10)/10
      } else if (valueScale < 10) {
        valueScale = Math.ceil(valueScale)
      } else if (valueScale < 100) {
        valueScale = Math.ceil(valueScale/10)*10
      } else if (valueScale < 1000) {
        valueScale = Math.ceil(valueScale/100)*100
      } else if (valueScale < 10000) {
        valueScale = Math.ceil(valueScale/1000)*1000
      } else if (valueScale < 100000) {
        valueScale = Math.ceil(valueScale/10000)*10000
      }
    }
    return valueScale
  }
})
