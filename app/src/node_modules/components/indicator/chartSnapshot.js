//main
var React           = require('react')


//components
var TableHeader     = require('./chartSnapshotHeader')
var TableGroup      = require('./chartSnapshotGroup')
var TableRow        = require('./chartSnapshotRow')

var makeGroupLabel  = require('utils/makeGroupLabel')
var makeDataLabel   = require('utils/makeDataLabel')

//helpers
var _               = require('lodash')

//logging
var log             = require('debug')('components:indicator:snapshot')


module.exports = React.createClass({

	propTypes : {
		flux        : React.PropTypes.object,    
		indicator   : React.PropTypes.object, // tehc urrent indicator
		breakdowns  : React.PropTypes.array, // breakdowns
		groups      : React.PropTypes.array, // groups for each dimension
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls'
    range       : React.PropTypes.object, // the top/bottom value for current dataset
	  sortBy      : React.PropTypes.string, // one of ["group","value"]    
    sortOrder   : React.PropTypes.boolean // the indicator sort order [indicator.order === 'DESC']
  },

	getInitialState: function () {
		return {
			sortOptions: ['group','value']
		}
	},

  render: function () {
		log('props', this.props)
    
    return (
			<div className='snapshot'>
				<table className='table'>
	        <TableHeader 
            breakdowns      = {this.props.breakdowns} 
            sortOptions     = {this.getInitialState.sortOptions } 
            sortBy          = {this.props.sortBy} 
            referenceDatum  = {this.referenceDatum()} 
          />
					<tbody className='table-body'>
            { (this.props.sortBy === 'groups') ? this.renderGroups() : this.renderValues() }
					</tbody>
				</table>
			</div>
    )
  },
  
  referenceDatum : function(){    
    var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
    // filter data by "all" for all breakdowns
    return _.filter(
      this.props.data,
      _.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all'))
    )
  },
          
  // render by group ////////////////////////////////////////////////////////////////////
  
  renderGroups : function(){
    return (
            <div>
            </div>
    )
  },


  // render by value ////////////////////////////////////////////////////////////////////
  
  renderValues : function(){
    var data = _(this.props.data).sortByOrder(['value'],this.props.sortOrder).value()
    var range = this.props.range
    // render each datum individually
    _.map(data, function (datum) {
      log('datum', datum)
      return (
        <TableRow datum = {this.formatRowData(
          datum,
          (range.top.value > range.bottom.value) ? range.top.value : range.bottom.value,
          this.referenceDatum().value
        )} />
      )
    }.bind(this))
  },
  
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  formatRowData : function (datum, maxValue, refValue) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 100
    refValue = typeof refValue !== 'undefined' ? refValue : 50
    log('datum', datum)

    return 
      // one cell for each active dimension
      _.map(this.props.breakdowns, function(dim){
        // get the group label
        return makeGroupLabel(this.props.flux,[dim.id],datum)
      })// finally the datum cell
      .push(this.formatBarCell(datum.value, maxValue, refValue))        
  },


	formatBarCell: function (val, maxValue, refValue) {
		return {
			type: 'horizontal-bar',
			value: Math.round((val/maxValue)*100, 2),
			label: makeDataLabel(val,this.props.indicator.type,this.props.indicator.unit),
			color: this.color()(val/maxValue) 
		}
	},

	color: function () {
		return d3InterpolateRGB('blue', 'red')
	},

})
