//main
var React           = require('react')


//components
var TableHeader     = require('./chartSnapshotHeader')
var TableGroup      = require('./chartSnapshotGroup')
var TableRow        = require('./chartSnapshotRow')

var makeGroupLabel  = require('utils/makeGroupLabel')
var makeDataLabel   = require('utils/makeDataLabel')



//helpers
var _               = require('lodash')

//logging
var log             = require('debug')('components:indicator:snapshot')


module.exports = React.createClass({

	propTypes : {
		flux        : React.PropTypes.object,    
		indicator   : React.PropTypes.object, // tehc urrent indicator
		breakdowns  : React.PropTypes.array, // breakdowns
		groups      : React.PropTypes.array, // groups for each breakdown
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls')
    range       : React.PropTypes.object, // the top/bottom value for current dataset
	  sortBy      : React.PropTypes.string, // one of ["group","value"]    
    sortDesc    : React.PropTypes.bool // the indicator sort order [indicator.order === 'DESC']
  },

	getInitialState: function () {
		return {
			sortOptions: ['group','value']
		}
	},

  render: function () {
		log('props', this.props)
    
    if (this.props.indicator.datatype !== 'categorical') {
    
      return (

        <div className='snapshot'>
          <table className='table'>
            <TableHeader 
              breakdowns      = {this.props.breakdowns} 
              sortOptions     = {this.getInitialState().sortOptions } 
              sortBy          = {this.props.sortBy} 
              referenceDatum  = {this.referenceDatum()} 
            />
            { (this.props.sortBy !== 'groups') ? this.renderGroups() : this.renderValues() }					
          </table>
        </div>
      )
    } else {
      return (
        <p> work in progress </p>
      )
    }
  },
  
  referenceDatum : function(){    
    var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
    // filter data by "all" for all breakdowns
    // TODO check for datasets that do not have "All people" average
    return _.filter(
      this.props.data,
      _.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all'))
    )[0]
  },
          
  // render by group ////////////////////////////////////////////////////////////////////
  
  cartProduct : function(sets){
    var end  = sets.length - 1
    var result = []

    function addTo(curr, start) {
      var first = sets[start]
        , last  = (start === end)

      for (var i = 0; i < first.length; ++i) {
        var copy = curr.slice()
        copy.push(first[i])

        if (last) {
          result.push(copy)
        } else {
          addTo(copy, start + 1)
        }
      }
    }

    if (sets.length) {
      addTo([], 0)
    } else {
      result.push([])
    }
    return result


  },
        
  renderGroups : function(dimension){
    
    
    // remove average values
    var breakdowns = this.props.breakdowns 
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })              
            })
    var groupProduct = this.cartProduct(this.props.groups)
    var range = this.props.range
    return (
      <tbody className='table-body'>     
        {
          _.map(groupProduct,function(group){
            var filter = {}
            _.each(group,function(row){
              filter[row.breakdown] = row.short
            })              
            var datum = _(data).filter(filter).value()
            return (
                <TableRow rowData = {this.formatRowData(
                  typeof datum[0] !== 'undefined' ? datum[0] : filter,
                  (range.top.value > range.bottom.value) ? range.top.value : range.bottom.value,
                  this.referenceDatum().value
                )} />                      
              ) 
          },this)
        }         
      </tbody>
    )
  },
  

  // render by value ////////////////////////////////////////////////////////////////////
  
  renderValues : function(){
    var breakdowns = this.props.breakdowns 
    // remove average values and sort
    var data = _(this.props.data)
            .filter(function(d){
              return _(breakdowns).every(function(bd){
                return d[bd.id] !== 'all'
              })              
            })
            .sortByOrder(['value'],this.props.sortDesc).value()
    var range = this.props.range
    // render each datum individually
    return (
      <tbody className='table-body'>
      {
        _.map(data, function (datum) {
          log('datum', datum)
          return (
            <TableRow rowData = {this.formatRowData(
              datum,
              (range.top.value > range.bottom.value) ? range.top.value : range.bottom.value,
              this.referenceDatum().value
            )} />
          )
        }.bind(this))
      }
     </tbody> 
    )
  },
  
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  formatRowData : function (datum, maxValue, refValue) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 1
    refValue = typeof refValue !== 'undefined' ? refValue : 0.5
    log('datum', datum)
    // one cell for each active dimension
    return _(this.props.breakdowns).map(function(bd){
        // get group cells
        return this.formatGroupCell (bd.id,datum)  
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.formatBarCell(datum.value, maxValue, refValue))           
  },
  formatGroupCell : function(breakdownId,datum) {
    return {
      type : 'text',
      label : makeGroupLabel(this.props.flux,[breakdownId],datum),
      className : 'group-label'
    }
  },

	formatBarCell: function (value, maxValue, refValue) {
		return {
			type: 'horizontal-bar',
			length: this.getBarLength(value,maxValue,this.props.indicator.datatype),
			label: makeDataLabel(value,this.props.indicator.datatype,this.props.indicator.unit),
			color: (value > refValue && this.props.sortDesc) ? 'blue' : 'orange'  
		}
	},
  getBarLength: function(value,maxValue,type){
    value = typeof value === 'number' ? value : 0
    if (type === 'percentage') {
      return Math.round((value/maxValue)*100, 2)
    } else {
      return value/maxValue 
    }
  }
})
