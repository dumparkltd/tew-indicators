//main
var React           = require('react')


//components
var TableHeader     = require('./chartSnapshotHeader')
var TableGroup      = require('./chartSnapshotGroup')
var TableRow        = require('./chartSnapshotRow')

var makeGroupLabel  = require('utils/makeGroupLabel')
var makeDataLabel   = require('utils/makeDataLabel')



//helpers
var _               = require('lodash')

//logging
var log             = require('debug')('components:indicator:snapshot')


module.exports = React.createClass({

	propTypes : {
		flux        : React.PropTypes.object,    
		indicator   : React.PropTypes.object, // tehc urrent indicator
		breakdowns  : React.PropTypes.array, // breakdowns
		groups      : React.PropTypes.array, // groups for each dimension
    data        : React.PropTypes.array, // filtered data by datasets,breakdowns&groups (including all 'alls'
    range       : React.PropTypes.object, // the top/bottom value for current dataset
	  sortBy      : React.PropTypes.string, // one of ["group","value"]    
    sortDesc    : React.PropTypes.bool // the indicator sort order [indicator.order === 'DESC']
  },

	getInitialState: function () {
		return {
			sortOptions: ['group','value']
		}
	},

  render: function () {
		log('props', this.props)
    
    return (

			<div className='snapshot'>
				<table className='table'>
	        <TableHeader 
            breakdowns      = {this.props.breakdowns} 
            sortOptions     = {this.getInitialState().sortOptions } 
            sortBy          = {this.props.sortBy} 
            referenceDatum  = {this.referenceDatum()} 
          />
					{ (this.props.sortBy === 'groups') ? this.renderGroups() : this.renderValues() }					
				</table>
			</div>
    )
  },
  
  referenceDatum : function(){    
    var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
    // filter data by "all" for all breakdowns
    // TODO check for datasets that do not have "All people" average
    return _.filter(
      this.props.data,
      _.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all'))
    )[0]
  },
          
  // render by group ////////////////////////////////////////////////////////////////////
  
  renderGroups : function(){
    return (
            <div>
            </div>
    )
  },


  // render by value ////////////////////////////////////////////////////////////////////
  
  renderValues : function(){
    var breakdowns = this.props.indicator.breakdowns // warning all available breakdowns not the ordered breakdowns
    var data = _(this.props.data)
            .reject(_.zipObject(breakdowns.split(','),_.fill(Array(breakdowns.length), 'all')))
            .sortByOrder(['value'],this.props.sortDesc).value()
    var range = this.props.range
    // render each datum individually
    return (
      <tbody className='table-body'>
      {
        _.map(data, function (datum) {
          log('datum', datum)
          return (
            <TableRow datum = {this.formatRowData(
              datum,
              (range.top.value > range.bottom.value) ? range.top.value : range.bottom.value,
              this.referenceDatum().value
            )} />
          )
        }.bind(this))
      }
     </tbody> 
    )
  },
  
  // for value sorted rows
  //data: Collection: -> [{Cell}, {Cell}...]]
  formatRowData : function (datum, maxValue, refValue) {
    maxValue = typeof maxValue !== 'undefined' ? maxValue : 100
    refValue = typeof refValue !== 'undefined' ? refValue : 50
    log('datum', datum)

    return 
      // one cell for each active dimension
      _(this.props.breakdowns).map(function(bd){
        // get the group label
        return makeGroupLabel(this.props.flux,[bd.id],datum)
      }.bind(this)).value()
      // finally the datum cell
      .concat(this.formatBarCell(datum.value, maxValue, refValue))           
  },


	formatBarCell: function (val, maxValue, refValue) {
		return {
			type: 'horizontal-bar',
			value: Math.round((val/maxValue)*100, 2),
			label: makeDataLabel(val,this.props.indicator.type,this.props.indicator.unit),
			color: (val > refValue && this.props.sortDesc) ? 'blue' : 'orange'  
		}
	},

})
